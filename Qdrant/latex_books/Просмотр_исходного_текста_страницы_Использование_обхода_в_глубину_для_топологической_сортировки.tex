{{Определение
|id=topsort_def
|definition=
'''Топологическая сортировка''' (англ. ''topological sort'') [[Ориентированный граф|ориентированного]] [[Основные определения теории графов|ациклического графа]] G = (V, E) представляет собой упорядочивание [[Основные определения теории графов|вершин]] таким образом, что для любого ребра (u, v) \in E(G) номер вершины u меньше номера вершины v\ . 
}}

== Применение ==
Топологическая сортировка применяется в самых разных ситуациях, например при создании параллельных алгоритмов, когда по некоторому описанию алгоритма нужно составить граф зависимостей его операций и, отсортировав его топологически, определить, какие из операций являются независимыми и могут выполняться параллельно (одновременно). Примером использования топологической сортировки может служить создание карты сайта, где имеет место древовидная система разделов. Также топологическая сортировка применяется при обработке исходного кода программы в некоторых компиляторах и IDE, где строится граф зависимостей между сущностями, после чего они инициализируются в нужном порядке, либо выдается ошибка о циклической зависимости.

Также с помощью топологической сортировки можно найти [[Гамильтоновы графы|гамильтонов путь]] в ациклическом графе.

== Постановка задачи ==
{{Теорема
|statement=G — ациклический ориентированный граф, тогда \exists \ \varphi : V \to \{ 1..n \} , uv \in E \Rightarrow \varphi (u) 
|proof=
Определим leave[u] как порядковый номер окраски вершины u в черный цвет в результате работы [[Обход в глубину, цвета вершин|алгоритма dfs]]. Рассмотрим функцию \varphi = n + 1 - leave[u] . Очевидно, что такая функция подходит под критерий функции \varphi из условия теоремы, если выполняется следующее утверждение:
{{Лемма
|statement=G — ациклический ориентированный граф, тогда uv \in E \Rightarrow leave[u] > leave[v]
|proof=
Рассмотрим произвольное [[Основные определения теории графов|ребро]] (u, v), исследуемое процедурой dfs. При исследовании вершина v не может быть серой, так как серые вершины в процессе работы dfs всегда образуют простой путь в графе, и факт попадания в серую вершину v означает, что в графе есть цикл из серых вершин, что противоречит условию утверждения. Следовательно, вершина v должна быть белой либо черной. Если вершина v — белая, то она становится потомком u, так что leave[u] > leave[v]. Если v — черная, значит, работа с ней уже завершена и значение leave[v] уже установлено. Поскольку мы все еще работаем с вершиной u, значение leave[u] еще не определено, так что, когда это будет сделано, будет выполняться неравенство leave[u] > leave[v]. Следовательно, для любого ребра (u, v) ориентированного ациклического графа выполняется условие leave[u] > leave[v].
}}
Таким образом, теорема доказана.
}}

== Алгоритм ==
Из определения функции \varphi мгновенно следует алгоритм топологической сортировки:

 // G {{---}} исходный граф
 '''function''' \mathtt{topologicalSort}():
 [[Использование обхода в глубину для поиска цикла|проверить граф G на ацикличность]]
 fill(\mathtt{visited}, false)
 '''for''' v \in V(G)
 '''if''' '''not''' \mathtt{visited}[v] 
 \mathtt{dfs}(v) 
 \mathtt{ans}.\mathtt{reverse}() 
 
 '''function''' \mathtt{dfs}(u):
 \mathtt{visited}[u] = true 
 '''for''' uv \in E(G)
 '''if''' '''not''' \mathtt{visited}[v] 
 \mathtt{dfs}(v) 
 \mathtt{ans}.\mathtt{pushBack}(u) 

Время работы этого алгоритма соответствует времени работы алгоритма поиска в глубину, то есть равно O(|V| + |E|).

==Пример==
Распространённая задача на топологическую сортировку {{---}} следующая. Есть n переменных, значения которых нам неизвестны. Известно лишь про некоторые пары переменных, что одна переменная меньше другой. Требуется проверить, не противоречивы ли эти неравенства, и если нет, выдать переменные в порядке их возрастания (если решений несколько — выдать любое). Легко заметить, что это в точности и есть задача о поиске топологической сортировки в графе из n вершин.

==См. также==
* [[Использование обхода в глубину для поиска цикла]]
* [[Использование обхода в глубину для проверки связности]]
* [[Использование обхода в глубину для поиска компонент сильной связности]]
* [[Использование обхода в глубину для поиска точек сочленения]]
* [[Использование обхода в глубину для поиска мостов]]

== Источники информации ==
*Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн — Алгоритмы: построение и анализ, 2-е издание. Пер. с англ. — М.:Издательский дом "Вильямс", 2010. — с.653 — 656.— ISBN 978-5-8459-0857-5 (рус.)
* [http://habrahabr.ru/blogs/algorithm/100953/#habracut Топологическая сортировка на habrahabr]
* [http://e-maxx.ru/algo/finding_cycle MAXimal :: algo :: Топологическая сортировка]
* [http://informatics.mccme.ru/mod/statements/view3.php?id=256&chapterid=166# Пример задачи на топологическую сортировку]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Обход в глубину]]