==Задача о динамической связности==
{{Задача
|definition = Для динамически изменяющегося дерева выполнить следующие запросы:
* '''\mathrm{link(u, w)}''' {{---}} добавить ребро (u, w) (при условии, что вершины u и w принадлежат разным деревьям),
* '''\mathrm{cut(u, w)}''' {{---}} разрезать ребро (u, w) (при условии, что ребро (u, w) принадлежит дереву),
* '''\mathrm{isConnected(u, w)}''' {{---}} определить принадлежат ли вершины u и w одной компоненте связности.
}}

Для решения поставленной задачи будем представлять дерево в виде его [[Эйлеровость графов|эйлерова графа]], а затем будем работать с [[Эйлеровость графов|эйлеровым обходом]] (англ.''Euler tour tree'') этого графа. Это позволит выполнять указанные запросы за O(\log n).

==Представление деревьев в виде эйлерова графа==

[[Файл:Tree.png|300px|thumb|left|Пример дерева]]
[[Файл:Euler graph.png|300px|thumb|right|Соответствующий эйлеров граф]]

Для представления [[Дерево, эквивалентные определения|дерева]] в виде [[Эйлеровость графов|эйлерового графа]] заменим каждое ребро \{u, v\} \ дерева на два ребра (u, v) и (v, u).

Получившийся [[Основные определения теории графов|ориентированный граф]] будет эйлеровым согласно [[Эйлеровость графов|критерию]].

Представим дерево в виде последовательности вершин, посещенных в порядке эйлерова обхода, начиная с вершины a.
[[Файл:Tour1.png|thumb|320px|center]]

==Операции c эйлеровыми обходами==

===Добавление ребра===

Для добавления ребра (c, g):
*Выберем любое вхождение вершины c в эйлеров обход дерева T1.
*Разрежем эйлеров обход T1 на две части:
*: A1 {{---}} часть обхода до выбранного вхождения вершины c, включая ее.
*: A2 {{---}} часть обхода после выбранного вхождения вершины c, включая ее.
*Аналогично, выберем любое вхождение вершины g в эйлеров обход дерева T2 и разрежем его на две части B1 и B2.
*Соберем результирующий эйлеров обход в порядке A1, B2, B1 (без первой повторяющейся вершины), A2.

Чтобы быстро находить место, где разрезать эйлеровы обходы деревьев T1 и T2, будем хранить эйлеровы обходы в двоичных деревьях поиска. 
Ключом вершины для построения дерева поиска будет время посещения этой вершины эйлеровым обходом.
Для каждой вершины дерева (T1, T2) будем хранить указатель на вершину в дереве поиска, которая соответствует вхождению вершины дерева в эйлеров обход. 
Тогда за O(1) переходим от вершины дерева к вершине дерева поиска, по которой за O(\log n) можно будет разделить дерево поиска на две части.

[[Файл:Link22.png |thumb|400px|center|Рис.1a Исходный лес Рис.1b Эйлеровы обходы деревьев Рис.1с Двоичные деревья поиска для хранения эйлеровых обходов Рис.1d Результирующий эйлеров обход]]

===Разрезание ребра===

Для удаления ребра (g, j):
*Найдем в эйлеровом обходе дерева T две пары посещений концов удаляемого ребра g,j и j,g, которые соответствуют прохождениям по ребру (g, j) в дереве T.
*Разрежем эйлеров обход дерева по этим парам на три части: A1, A2, A3.
*Соединив A1 и A3 (без повторяющейся первой вершины), получим эйлеров обход первого дерева, а A2 дает эйлеров обход второго дерева.

Чтобы быстро находить места в эйлеровом обходе, которые соответствуют прохождению удаляемого ребра в дереве, будем для каждого ребра в дереве хранить ссылку на те места эйлерова обхода, где последовательно посещаем концы удаляемого ребра.
Так, для ребра (g, j) храним ссылки на узлы дерева поиска, соответствующие парам посещений концов этого ребра.

[[Файл:Link23.png |thumb|400px|center|Рис.1a Исходное дерево Рис.1b Эйлеров обход исходного дерева Рис.1с Двоичное дерево поиска для хранения эйлерового обхода Рис.1d Эйлеровы обходы получившихся деревьев]]

===Проверка на связность===
Для того, чтобы проверить, лежат ли две вершины в одном дереве, достаточно подняться от вхождения каждой вершины в эйлеров обход (ссылку на которое мы храним) до корня дерева поиска, хранящего этот эйлеров обход.

==Способы реализации структуры==

===Сбалансированное дерево поиска===

Будем хранить последовательность вершин эйлерова обхода в виде сбалансированного двоичного дерева поиска, например, в виде [[Красно-черное дерево|красно-черного дерева]]. При построении дерева ключом вершины будет время посещения этой вершины эйлеровым обходом. 

Операции объединения и разделения красно-черных деревьев выполняется за O(\log n)[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.109.4875&rep=rep1&type=pdf Ron Wein {{---}} Efficient Implementation of Red-Black Trees.].

===Декартово дерево по неявному ключу===

Также, можем хранить последовательности вершин эйлерова обхода в [[Декартово_дерево_по_неявному_ключу|декартовом дереве по неявному ключу]]. Глубина декартового дерева, построенного на массиве из n вершин, будет поддерживаться равной O(\log n). 

Операции объединения и разделения также выполняются за O(\log n).

==См. также==
* [[Link-Cut Tree]]

== Примечания ==

==Источники информации==
* [https://en.wikipedia.org/wiki/Euler_tour_technique Wikipedia {{---}} Euler tour technique]
* [http://courses.csail.mit.edu/6.851/spring07/scribe/lec05.pdf Advanced Data Structures {{---}} Euler tour trees]
* [http://codeforces.com/blog/entry/18369?mobile=true&locale=en CodeForces {{---}} On Euler tour trees]
* [http://logic.pdmi.ras.ru/csclub/node/2819 Лекториум{{---}} Лекция Павла Маврина об эйлеровых обходах]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Обходы графов]]
[[Категория: Эйлеровы графы]]