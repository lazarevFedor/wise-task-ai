__TOC__

{{Определение
|definition='''Минимально узкое остовное дерево''' (англ. ''Minimum bottleneck spanning tree'', ''MBST'') в связанном взвешенном неориентированном графе - [[Остовные деревья: определения, лемма о безопасном ребре|остовное дерево]] графа, у которого максимальное ребро минимально.
}}
{{Определение
|definition='''Узким ребром''' (англ. ''bottleneck edge'') в графе назовём максимальное по весу.
}}
{{Определение
|definition=Остовное дерево является '''минимально узким''' (англ. ''minimum bottleneck''), если в графе нет остовного дерева с меньшим узким ребром.
}}
== Свойства минимального узкого остовного дерева ==
{{Утверждение с MBST
|statement=Каждое минимальное остовное дерево является \mathrm{MBST}.
|proof=Предположим, если минимальное остовное не является \mathrm{MBST}, значит в графе существует набор ребер которые мы не взяли в наш остов, при замене на которые, наше дерево станет \mathrm{MBST}. Также рёбра вне остова должны быть меньше рёбер из остова, чтобы уменьшить минимальное максимально ребро. Но по определению \mathrm{MST}, сумма рёбер дерева минимальна, значит вне остова нету рёбер с меньшим весом. Так как наше предположение неверно, \mathrm{MST} является \mathrm{MBST}.
}}
{{Утверждение с MBST
|statement=\mathrm{MBST} не всегда является минимальным остовным деревом.
|proof=Рассмотрим пример, где \mathrm{MBST} не является минимальным остовным деревом:
[[Файл:MBST-example.png|left|thumb|700px|Пример MBST дерева.]]
[[Файл:MSTisMBST.png|left|thumb|700px|Пример MST дерева.]]
}}

== Проверка остовного дерева на узкость ==
{{Задача
|definition=Проверить остовное дерево в графе на \mathrm{MBST}.
}}
=== Алгоритм ===
Построим новый граф, добавим туда все рёбра меньше максимального из нашего остова. Если в результате у нас получится связный граф, значит мы сможем выделить из него остовное дерево с меньшим узким ребром - наше дерево не самое узкое. Иначе, для связности графа нам необходимо добавить максимальные рёбра - наше дерево является минимально узким. 
Найдём максимальное ребро в нашем дереве. Добавим рёбра с весом меньше максимального при помощи [[СНМ (наивные реализации)|СНМ]], чтобы определить его связность. Если в результате у нас все вершины лежат в одном множестве, значит наше дерево не является \mathrm{MBST}, иначе оно \mathrm{MBST}.
=== Асимптотика ===
По каждому ребру пройдём один раз, для поиска максимального, займёт O(N), где N - число рёбер в графе.Работа с СНМ займет O(N\alpha(V)), где \alpha — обратная функция Аккермана, которая не превосходит 4 во всех практических приложениях и которую можно принять за константу.В результате получаем алгоритм работающий за линейное время O(N).

=== Псевдокод ===
Все рёбра графа будем хранить в списке \mathtt{e}, а рёбра остовного дерева в списке \mathtt{tree}.
В каждом ребре \mathtt{Edge} храним следующую информацию:
* \mathtt{from}, \mathtt{to} {{---}} соединяемые вершины
* \mathtt{cost} {{---}} вес ребра

 '''bool''' ifMBST('''Edge'''[] e, '''Edge'''[] tree):
 '''int''' united = 0 // Сколько вершин мы объединили 
 '''int''' maxEdge = -\infty
 '''for''' i = 1 '''to''' tree.size
 maxEdge = max(maxEdge, tree[i].cost) // Поиск максимального ребра в дереве 
 '''for''' i = 1 '''to''' n
 '''if''' e[i].cost >= maxEdge // Не соединяем вершины, если ребро не меньше максимального 
 '''continue'''
 '''if''' find(e[i].from]) != find(e[i].to) // Объединяем вершины, если они в разных множествах 
 united++
 unite(e[i].from,e[i].to)
 '''if''' united == e.size - 1 // Дерево подходит, если в результате мы соединили все вершины 
 '''return''' ''true''
 '''else''' 
 '''return''' ''false''

==Cм. также==
*[[Алгоритм Краскала]]
*[[Остовные деревья: определения, лемма о безопасном ребре]]
*[[СНМ (наивные реализации)]]

==Источники информации==
*[https://en.wikipedia.org/wiki/Minimum_bottleneck_spanning_tree Википедия — Minimum bottleneck spanning tree]

[[Категория: Алгоритмы и структуры данных]] 
[[Категория: Остовные деревья]]
[[Категория: Построение остовных деревьев]]