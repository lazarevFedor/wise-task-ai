== Алгоритм ==
=== Описание алгоритма ===
Алгоритм находит [[Эйлеров цикл, Эйлеров путь, Эйлеровы графы, Эйлеровость орграфов|Эйлеров цикл]] как в [[Ориентированный граф|ориентированном]], так и в [[Основные определения теории графов#Неориентированные графы|неориентированном графе]]. Перед запуском алгоритма необходимо [[Эйлеров цикл, Эйлеров путь, Эйлеровы графы, Эйлеровость орграфов|проверить граф на эйлеровость]]. Чтобы построить [[Эйлеров цикл, Эйлеров путь, Эйлеровы графы, Эйлеровость орграфов|Эйлеров путь]], нужно запустить алгоритм из вершины с нечетной степенью.
Алгоритм напоминает поиск в глубину. Главное отличие состоит в том, что пройденными помечаются не вершины, а ребра графа. Начиная со стартовой вершины v строим путь, добавляя на каждом шаге не пройденное еще ребро, смежное с текущей вершиной. Вершины пути накапливаются в [[Стек | стеке]] S. Когда наступает такой момент, что для текущей вершины w все инцидентные ей ребра уже пройдены, записываем вершины из S в ответ, пока не встретим вершину, которой инцидентны не пройденные еще ребра. Далее продолжаем обход по не посещенным ребрам.

=== Псевдокод ===

'''Код проверки графа на эйлеровость:'''
 '''boolean''' checkForEulerPath():
 '''int''' OddVertex = 0
 '''for''' v : v \in V
 '''if''' \operatorname{deg}(v) '''mod''' 2 == 1
 OddVertex++
 '''if''' OddVertex > 2 // если количество вершин с нечетной степенью больше двух, то граф не является эйлеровым
 '''return''' ''false''
 '''boolean''' visited(|V|, ''false'') // массив инициализируется значениями ''false''
 '''for''' v : v \in V
 '''if''' \operatorname{deg}(v) > 0
 dfs(v, visited)
 '''break'''
 '''for''' v : v \in V
 '''if''' \operatorname{deg}(v) > 0 '''and''' '''not''' visited[v] // если количество компонент связности, содержащие ребра, больше одной,
 '''return''' ''false'' // то граф не является эйлеровым
 '''return''' ''true'' // граф является эйлеровым

'''Код построения эйлерова пути:'''
 '''function''' findEulerPath(v): // если граф является полуэйлеровым, то алгоритм следует запускать из вершины нечетной степени 
 '''for''' u : u \in V
 '''if''' \operatorname{deg}(u) '''mod''' 2 == 1
 v = u
 '''break'''
 S.push(v) // S {{---}} стек
 '''while not''' S.empty()
 w = S.top()
 found_edge = '''False'''
 '''for''' u : u \in V
 '''if''' (w, u) \in E // нашли ребро, по которому ещё не прошли
 S.push(u) // добавили новую вершину в стек
 E.remove(w, u)
 found_edge = '''True'''
 '''break'''
 '''if''' '''not''' found_edge
 S.pop() // не нашлось инцидентных вершине w рёбер, по которым ещё не прошли
 print(w)

=== Доказательство корректности ===
{{Лемма
|statement=Данный алгоритм проходит по каждому ребру, причем ровно один раз.
|proof=Допустим, что в момент окончания работы алгоритма имеются еще не пройденные ребра. Поскольку граф связен, должно существовать хотя бы одно не пройденное ребро, инцидентное посещенной вершине. Но тогда эта вершина не могла быть удалена из стека S, и он не мог стать пустым. Значит алгоритм пройдёт по всем рёбрам хотя бы один раз.
Но так как после прохода по ребру оно удаляется, то пройти по нему дважды алгоритм не может.
}}
Вершина v, с которой начат обход графа, будет последней помещена в путь P. Так как изначально стек пуст, и вершина v входит в стек первой, то после прохода по инцидентным ребрам, алгоритм возвращается к данной вершине, выводит ее и опустошает стек, затем выполнение программы завершается.
{{Лемма
|statement=Напечатанный путь P {{---}} корректный маршрут в графе, в котором каждые две соседние вершины u_i и u_{i+1} будут образовывать ребро (u_i, u_{i+1}) \in E.
|proof=Будем говорить, что ребро (w,u) представлено в S или P, если в какой-то момент работы алгоритма вершины w и u находятся рядом. Каждое ребро графа представлено в S. Рассмотрим случай, когда из S в P перемещена вершина u, а следующей в S лежит w. Возможны 2 варианта:
*На следующем шаге для вершины w не найдётся инцидентного ребра, тогда w переместят в P, и ребро (w,u) будет представлено в P.
*Иначе будет пройдена некоторая последовательность ребер {u_1, u_2, ..., u_k}, начинающаяся в вершине w и проходящая по ребру (w, u_1). Докажем, что данный проход {u_1, u_2, ..., u_k} закончится в вершине w:
#Ребро (u_{k-1}, u_k) не может быть инцидентно вершинам u_1, \dots , u_{k-2}, иначе степень вершины u_k окажется нечетной.
#Предположим, что (u_{k-1}, u_k) инцидентно вершине, пройденной при обходе графа из вершины u. Но это неверно, так как тогда бы данные вершины пройдены ранее.
Из этого следует, что мы закончим обход в вершине w. Следовательно, данная вершина первой поместится в P вслед за u, и ребро (w, u) будет представлено в P.
}}
{{Теорема
|id=proof1
|statement=Данный алгоритм находит корректный эйлеров путь.
|proof=Из предыдущих лемм следует, что P {{---}} искомый эйлеров путь и алгоритм работает корректно.
}}
=== Рекурсивная реализация ===

 '''function''' findEulerPath(v : Vertex):
 '''for''' (v,u) \in E
 remove (v, u)
 findEulerPath(u)
 print(v)

=== Время работы ===
Если реализовать поиск ребер инцидентных вершине и удаление ребер за O(1), то алгоритм будет работать за O(E).
Чтобы реализовать поиск за O(1), для хранения графа следует использовать списки смежных вершин; для удаления достаточно добавить всем ребрам свойство \mathtt{deleted} бинарного типа.

=== Рекурсивная реализация за O(E) ===
Заведём 2 массива: vis и first 
vis[i] (bool) - посещено ли ребро с индексом i (i \in 0..(E-1)) 
(массив нужен, чтобы за O(1) проверять, доступно ребро или нет) 
first[u] (int) - индекс первой вершины v в списке смежных вершин, такой что ребро (u,v) не посещено (u \in 0..(V-1))
(массив нужен, чтобы в среднем за O(1) находить доступное ребро) 

Изначально оба массива заполнены нулями. 

Граф будем хранить в виде списков смежных вершин. Для каждой вершины u построим список g[u] из пар вида (i,v) 
i - индекс ребра (u,v) 
v - номер смежной вершины 

После ввода графа нужно запустить euler(0) или от любой другой вершины. 

 '''function''' euler(u):
 '''while''' (first[u] u].size()): //если first[u] = g[u].size, рёбра во все смежные вершины уже посещены
 i,v = g[u][first[u]]
 first[u] += 1
 '''if''' (!vis[i]): vis[i] = true euler(v) print(v)
 
== См. также ==
* [[Гамильтоновы графы]]
* [[Покрытие рёбер графа путями]]
* [[Произвольно вычерчиваемые из заданной вершины графы]]

== Источники информации ==
* [http://ru.wikipedia.org/wiki/Эйлеров_цикл Википедия {{---}} Эйлеров цикл]
* [http://e-maxx.ru/algo/euler_path Статья про нахождение Эйлерова пути с реализацией на С++ на сайте e-maxx.ru]
* [http://ивтб.рф/exams/саод/36.htm Статья про нахождение Эйлерова пути с реализацией на Pascal на сайте ивтб.рф]
* [https://www.youtube.com/watch?v=ryw059C6oK8 Видео-лекция А.С.Станкевича про нахождение Эйлерова цикла с реализацией на C++ на сайте youtube.com]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Обходы графов]]
[[Категория: Эйлеровы графы]]