== Критерий Тарьяна ==
{{Теорема
|about=
критерий Тарьяна минимальности остовного дерева
|statement=
Остовное дерево минимально тогда и только тогда, когда для любого ребра, не принадлежащего остову, цикл, образуемый этим ребром при добавлении к остову, не содержит рёбер тяжелее этого ребра.
|proof=
 \Rightarrow 

Докажем, что остовное дерево, состоящее из ребер наименьшего веса на циклах {{---}} минимально.

Предположим противное: пусть остовное дерево A состоит из всех минимальных ребер на циклах, тогда оно не минимально. 

Если A не минимально, то его можно улучшить, значит есть ребро, которое имеет наименьший вес на цикле и не принадлежит дереву. Следовательно, дерево построено не на минимальных ребрах в циклах {{---}} противоречие.

 \Leftarrow 

Построим минимальное остовное дерево A , с помощью общего алгоритма построения MST. Докажем, что оно имеет минимальные ребра на каждом цикле.
 
 '''function''' Generic MST( G ): 
 A = \{ \} 
 '''while''' A не является остовом
 '''do''' найти безопасное ребро ( u, v ) \in E для A // нужное ребро находится с помощью [[Лемма о безопасном ребре|леммы о безопасном ребре]] 
 A = A \cup \{( u, v )\} 
 '''return''' A 

Заметим, что дерево A состоит полностью из безопасных ребер, так как на каждом шаге добавлялось безопасное ребро.

Теперь, рассмотрим какой-нибудь разрез (S, T) уже построенного дерева A и пересекающее ребро (u, v) , причем u \in S , а v \in T . Найдем путь в изначальном графе G , соединяющий вершины u и v . Так как они находятся в разных компонентах связности, то какое-нибудь ребро (a, b) \notin A тоже будет пересекать разрез (S, T) . Очевидно, что w(u, v) \leqslant w(a, b) , так как первое {{---}} безопасное ребро. 

Следовательно, любое ребро не принадлежащее A не легче ребер принадлежащих A на этом цикле.

}}

== Уникальность остовного дерева ==
{{Задача
|definition=Поиск минимального остовного дерева и проверка его на уникальность.
}}
Алгоритм решения
Построим минимальное остовное дерево используя [[алгоритм Краскала]]. 
Рассмотрим рёбра вне остова в любом порядке. Очередное обозначим e = (u, v). Рассмотрим максимальное ребро на пути u и v внутри остова:
*Если его вес совпадает с весом ребра, то при добавлении ребра в остов, мы получим остов с циклом на котором несколько рёбер имеют одинаковый вес, значит мы можем удалить любое из них и остовное дерево будет всё ещё минимальным, это нарушает уникальность дерева. На этом алгоритм завершается и по критерию Тарьяна мы можем сказать, что в графе можно построить несколько остовных деревьев. 
*Если его вес больше ребра, то заменив ребро мы получим остов с большим весом, этот случай не влияет на уникальность. 
*Его вес не может быть меньше ребра из остова, иначе мы смогли бы построить минимальное остовное дерево с меньшим весом.
После рассмотрения всех рёбер, если мы не нашли ребро вне остова, при добавлении которого создаётся цикл с максимальным ребром таким же как и на пути u и v, то в графе нету другого остовного дерева и наше дерево уникально.
Искать максимальное ребро на пути u и v в дереве мы можем при помощи [[Heavy-light декомпозиция|heavy-light декомпозиции]].
Асимптотика
Построение минимального остовного дерева работает за O(N \log N), нахождение максимального ребра за O(\log N), максимальное количество рёбер вне остова не больше N, каждое ребро проверяется за O(\log N). Построение heavy-light декомпозиции работает за O(N), остов мы построим один раз, heavy-light декомпозицию тоже один раз, каждое ребро мы не больше одного раза проверим на замену, сложность алгоритма O(N \log N).

== См.также ==
* [[Остовные деревья: определения, лемма о безопасном ребре]]
* [[Минимально узкое остовное дерево]]
* [[Алгоритм Краскала]]
* [[Алгоритм Борувки]]
* [[Алгоритм Прима]]

==Источники информации==
* Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К. {{---}} Алгоритмы. Построение и анализ.

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Остовные деревья ]]