'''Алгоритм Голдберга-Тарьяна''' (англ. ''Goldberg-Tarjan'') {{---}} алгоритм, решающий задачу нахождения максимального потока в транспортной сети за O(VE \log(V)). Можно считать модификацией алгоритма Диница.
==Алгоритм==
===Идея===
Вспомним [[Схема алгоритма Диница|алгоритм Диница]]. Пусть есть сеть G^0_f {{---}} некоторый ориентированный ациклический граф, S, T {{---}} исток и сток соответственно. Схема алгоритма Диница:
# При помощи [[Обход в глубину, цвета вершин|обхода в глубину]] находим путь из S в T.
# Находим ребро с минимальной пропускной способностью
# Вдоль пути увеличиваем поток на минимальную пропускную способность

Попытаемся ускорить процесс поиска пути из S в T. Для этого, для каждой вершины зафиксируем какое-либо, не более, чем одно, исходящее из нее ребро. Граф ацикличен, значит зафиксированные ребра будут образовывать лес корневых деревьев. Корнем каждого дерева будет вершина, у которой нет зафиксированного ребра.
В каждой вершине будем дополнительно хранить остаточную пропускную способность исходящего зафиксированного ребра.

[[Файл:Голдберг-Тарьян.граф.png |500px |thumb|center| Желтым выделены зафиксированные ребра. Тогда T {{---}} корень дерева]]

Пусть каждое дерево поддерживает следующие операции:
# Вычислить минимум на пути от вершины до корня (1).
# Прибавить константу к числам на пути от вершины до корня (2).
# Отрезать поддерево по ребру. Отрезанное поддерево отделяется и существует независимо от исходного дерева (3).
# Подвесить дерево. Пусть есть дерево с корнем A, дерево с вершиной B. Операция позволяет Создать ребро из A в B и тем самым подвесить дерево к вершине (4).

Заметим, что именно эти операции поддерживает [[Link-Cut Tree|Link-Cut tree]] и умеет их выполнять за O(\log(N)).

===Поиск пути===
Научимся находить путь из S в T в описанной выше сети при помощи леса корневых деревьев. Будем отдельно хранить дерево с потоками и дерево с пропускными способностями.

* Начало.
* '''Шаг 1'''. Пусть U {{---}} корень дерева, в котором лежит S.
* '''Шаг 2'''. Если вершина U совпала с вершиной T переходим к '''шагу 6''', иначе к '''шагу 3'''.
* '''Шаг 3'''. Выберем следующее ненасыщенное исходящее ребро. Если ребра нет {{---}} переходим к '''шагу 7'''. Ребра рассматриваем также, как и в алгоритме Диница, с глобальным итератором. Т.е начинать просмотр будем с последнего подошедшего ребра. Если ребро не подошло {{---}} больше его не рассматриваем. 
* '''Шаг 4'''. Пусть просматриваем ненасыщенное ребро, ведущее в некоторую вершину V. Подвесим корень U через это ребро к вершине V, выполнив (4) запрос.
* '''Шаг 5'''. В U записываем число, равное остаточной пропускной способности ребра. Переходим к '''шагу 1'''.
* '''Шаг 6'''. Возвращаем найденный путь.
* '''Шаг 7'''. Пути из S в T нет.
* Конец.

===Улучшение пути===
Путь из S в T найден, теперь научимся улучшать путь. Нужно обновить значения пропускных способностей и потоков через вершины этого пути. Тогда:
* При помощи (1) запроса можно найти узкое место (ребро с минимальной остаточной пропускной способностью) на этом пути и его пропускную способность.
* При помощи (2) запроса можно вычесть из всех ребер на этом пути пропускную способность узкого места, а также, прибавить ее к потоку.

Пусть после (2) запроса появилось нулевое ребро. Запрос минимума от S до корня будет возвращать 0. Поэтому, такие ребра нужно отрезать, выполнив (4) запрос по этому ребру. Стоит заметить, что нулевых ребер может получиться несколько, в случае нескольких минимумов.

===Итоговый алгоритм===

Объединим вышесказанное в алгоритм Голдберга-Тарьяна. 
Пусть дана сеть. Требуется в этой сети найти поток f(S, T) максимальной величины.

* Начало.
* '''Шаг 1'''. Для каждого ребра (u, v) данной сети G зададим f(u, v) = 0.
* '''Шаг 2'''. Если есть путь из S в T {{---}} переходим к '''шагу 3'''.
* '''Шаг 3'''. Выполняем (1) запрос, узкое место и пропускную способность. Если пропускная способность положительна, переходим к '''шагу 4''', иначе к '''шагу 5'''.
* '''Шаг 4'''. ''Улучшение пути''. Обновляем значения потока и пропускной способности при помощи (2) запроса.
* '''Шаг 5'''. ''Удаление нулевых ребер''. Обрезаем нулевые ребра при помощи (3) запроса. Переходим к '''шагу 2'''.
* Конец.

==Время работы==
[[Link-Cut Tree|Link-Cut tree]] выполняет все вышеописанные запросы за O(\log(N)), оценим время работы алгоритма.

Очевидно, что просмотров ребер суммарно O(E), как и в алгоритме Диница. Переход к следующему ребру происходит в следующих случаях:
# Просматриваемое ребро насыщено.
# Дерево разрезается по нулевому ребру.
# Ребро не лежит в сети кратчайших путей.

На каждый просмотр тратится не O(1) а O(\log(V)), потому что перед тем, как посмотреть на следующее ребро делается запрос. Значит время работы этой части {{---}} O(E \log(V)).

Следующий шаг в алгоритме Диница {{---}} сумма длин путей. Раньше считалось за O(V^2), так как на каждый путь обход в глубину тратил время, пропорциональное длине этого пути. Сейчас тратится только O(\log(V)) на каждый путь. Если путь найден, значит до него дошли, значит это соответствует одному запросу. Поэтому тратим на каждый путь тоже логарифм O(\log(V)).

Тогда имеем ассимптотику O(E\log(V) + V \log(V)) = O((V + E) \log(V)). И, суммарно, если подставить в алгоритм Диница будем иметь ассимптотику O(VE \log(V)) .

== См. также ==
* [[Алгоритм Форда-Фалкерсона, реализация с помощью поиска в глубину|Алгоритм Форда-Фалкерсона, реализация с помощью поиска в глубину]]
* [[Алоритм Эдмондса-Карпа|Алоритм Эдмондса-Карпа]]
* [[Алгоритм масштабирования потока|Алгоритм масштабирования потока]]
* [[Метод проталкивания предпотока|Метод проталкивания предпотока]]

== Источники информации ==
*[https://www.lektorium.tv/lecture/14408 Lektorium {{---}} Лекция А.С. Станкевича]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Задача о максимальном потоке ]]