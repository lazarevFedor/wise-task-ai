__TOC__
{{Задача
|definition = Пусть дан граф G = \left \langle {V, E} \right \rangle, удовлетворяющий условию [[Теорема Оре|теоремы Оре]] или [[Теорема Дирака|теоремы Дирака]]. Требуется найти в нем гамильтонов цикл.
}}
== Описание алгоритма ==

Поступим следующим образом: заведем очередь и положим в нее все вершины нашего графа (не важно в каком порядке). Пусть n = \left | V \right |. Тогда n(n -1) раз будем делать следующую операцию:

* Пусть v_1 {{---}} это голова очереди, v_2 {{---}} следующая за ней вершина и так далее. Если между первой и второй вершиной в очереди есть ребро в графе G, то перемещаем первую вершину в конец очереди и переходим к следующей итерации.
* Если между первой и второй вершиной в очереди ребра нет, то найдем вершину v_i, где i > 2, такую что, ребра v_1v_i, v_2v_{i+1} \in E (так как у нас для графа выполнена либо [[Теорема Оре|теорема Оре]], либо [[Теорема Дирака|теорема Дирака]], то такая вершина обязательно найдется; чуть позже докажем это явно). После чего поменяем в очереди местами вершины v_2 и v_i, v_3 и v_{i-1}, v_{2+j} и v_{i-j}, и так далее, пока 2 + j (то есть j пробегает все значения от 0 до значения заданного неравенством). Теперь у нас появилось ребро между первой и второй вершинами в очереди (теперь вторая вершина, это та, которая была до разворота на i-й позиции), а также, гарантированно существует ребро между i-й и (i+1)-й вершинами очереди. После этого, так же как и в первом случае, оправляем первую вершину в конец очереди.

Таким образом после n итераций, мы получаем последовательность (вершины лежащие в очереди), где любые 2 соседние вершины соединены ребром, все вершины графа находятся в этой последовательности, и более того, каждая ровно один раз, а также существует ребро между последней и первой вершинами очереди, а это и значит, что мы решили поставленную задачу.

== Псевдокод ==
Функция \mathtt{findHamiltonianCycle} получает на вход граф G и находит гамильтонов цикл в нем.

* queue {{---}} очередь вершин графа G = \left \langle {V, E} \right \rangle
{| width = 100%
|-
| 
 '''function''' findHamiltonianCycle(\left \langle {V, E} \right \rangle):
 '''for''' v \in V: // Добавляем все вершины графа в очередь
 queue.pushBack(v)
 '''for''' k = 0..n * (n - 1)
 '''if''' (queue.at(0), queue.at(1)) \notin E // Проверяем существования ребра между первой и второй вершинами очереди
 i = 2 
 '''while''' (queue.at(0), queue.at(i)) \notin E '''or''' (queue.at(1), queue.at(i + 1)) \notin E
 i++ // Ищем индекс удовлетворяющую условию вершины
 queue.swapSubQueue(1, i) // Разворачиваем часть перестановки от 1-й до найденной позиции включительно
 queue.pushBack(queue.top())
 queue.pop()
|}

== Доказательство алгоритма ==

{{Лемма
|statement=Каждый раз, когда нам надо искать вершину v_i, где i > 2, такую что v_1v_i, v_2v_{i+1} \in E, такая вершина действительно существует.
|proof=Рассмотрим множество S = \{i\mid v_1v_i \in E\}, состоящее из индексов вершин, смежных с v_1, и множество T = \{i+1 \mid v_2v_{i+1} \in E\}, индексов вершин смежных с v_2. Заметим, что S \subset \{3, 4, \ldots, n\}, а T \subset \{2, 3, \ldots, n - 1\}, тогда S\cup T\subset \{2, 3, \ldots, n\} , а значит \left\vert S\cup T\right\vert \leqslant n-1, в то же время \left\vert S \right\vert + \left\vert T \right\vert = \operatorname{deg} v_1 + \operatorname{deg} v_2 \geqslant n (по условию [[Теорема Оре|теоремы Оре]] или [[Теорема Дирака|теоремы Дирака]]). Из этого следует, что S\cap T\ne \varnothing, а это и значит, что искомая вершина существует.
}}

{{Лемма
|statement=После n(n - 1) итераций между каждой парой соседних вершин очереди существует ребро.
|proof=Достаточно заметить, что каждую итерацию алгоритма, мы, в случае отсутствия ребра, между v_1 и v_{2} увеличиваем количество пар соседних в очереди вершин, между которыми есть ребро, как минимум на 1 (это прямое следствие условия поиска нужной вершины, в случае отсутствия ребра), для поиска такой пары требуется не более n итераций. Таких пар изначально не более n, откуда следует, что после n итераций, второе условие будет выполнено.
}}

{{Теорема
|statement=Алгоритм находит гамильтонов цикл.
|proof=Из предыдущих лемм следует корректность алгоритма.
}}

== Сложность алгоритма ==

Поиск вершины, удовлетворяющей заданному условию работает за O(n), а таких поисков будет осуществлено не более чем n. Оставшиеся n(n - 2) итерации выполняются за O(1).
Тогда алгоритм выполняется за O(n^2).

== См.также ==
*[[Гамильтоновы графы]]
*[[Теорема Оре]]
*[[теорема Дирака|Теорема Дирака]]
*[[Очередь]]

== Источники информации ==
*[http://rain.ifmo.ru/cat/view.php/theory/graph-circuits-cuts/hamiltonian-2005 Дискретная математика: Алгоритмы {{---}} Гамильтоновы графы]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Обходы графов]]
[[Категория: Гамильтоновы графы]]