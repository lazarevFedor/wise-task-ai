Дан неориентированный [[Основные определения теории графов#Граф| граф]] G . Найти все [[Мост, эквивалентные определения | мосты]] в G за время O(|V| + |E|)
 
== Алгоритм ==
{{Теорема
|statement=
Пусть T — дерево [[Обход в глубину, цвета вершин | обхода в глубину графа]] G. Ребро (u, v) является мостом тогда и только тогда, когда (u, v) \in T и из вершины v и любого ее потомка нет обратного ребра в вершину u или предка u 
|proof=
 \Leftarrow 
Удалим (u, v) из G. Докажем, что мы не сможем достичь ни одного из предков v (в частности u ). Докажем этот факт от противного. 
Пусть это не так, и w — предпоследняя вершина на пути от v до ее предка x . Очевидно, (w, x) не ребро дерева (в силу единственности пути в дереве). Если (w, x) — обратное ребро, то это противоречит условию теоремы, так как x — предок u. Следовательно мы не достигнем предков v, а значит количество компонент связности увеличилось, поэтому ребро (u, v) является мостом.
 \Rightarrow 
Пусть существует удовлетворяющее условию обратное ребро (x, w). Тогда (u, v) лежит на цикле x \rightsquigarrow v \rightarrow u \rightsquigarrow w \rightarrow x и не может быть мостом.
}}
==== Функция ret(v) ====
Определим функцию ret(v), где v \in V, как минимум из следущих величин 

* enter(v) [[Использование обхода в глубину для топологической сортировки | время входа в вершину v ]] 
* enter(x), где x — потомок v 
* enter(w), где (w, x) — обратное ребро, а w — потомок v (в нестрогом смысле) 

===Лемма===
{{Лемма
|statement = Ребро (u, v) является мостом тогда и только тогда, когда (u, v) принадлежит дереву обхода в глубину и ret(v) > enter(u)
| proof = Рассмотрим вершину v или её потомка. Из нее есть обратное ребро в предка v тогда и только тогда, когда найдется такой сын t, что ret[t] \le enter[v]. Если ret[t] = enter[v], то найдется обратное ребро, приходящее точно в v. Если же ret[t] , то это означает наличие обратного ребра в какого-либо предка вершины v.

Таким образом, если для текущего ребра (v, t) (принадлежащего дереву поиска) выполняется ret[t] > enter[v], то это ребро является мостом; в противном случае оно мостом не является. 
}}

{{Утверждение
|statement =
ret(v) = \min( enter(v) , enter(p), ret(u) 
) , где (v, p) — обратное ребро, (v, u) — ребро дерева
|proof =
[[Файл:Bridges_dfs.png|300px|thumb|right|В скобах у вершины u указаны enter[u] и ret[u]. Мостами будут красные ребра]]
#enter(v) По определению функции ret 
#enter(p), (v, p) — обратное ребро p достижима из v по одному обратному ребру, значит величина ret(v) не больше enter(p) 
#ret(u), u — потомок v Так как вершина u — потомок v, то обратное ребро из ее поддерева является обратным ребром из поддерева v 
}}

=== Псевдокод ===
 '''function''' dfs(v):
 time = time + 1
 enter[v] = time
 ret[v] = time 
 '''for''' всех u смежных с v
 '''if''' (v, u) — обратное ребро
 ret[v] = min(ret[v], enter[u])
 '''if''' вершина u — белая
 dfs(u)
 ret[v] = min(ret[v], ret[u]) 
 '''if''' ret[u] > enter[v] 
 ребро (v, u) — мост

==См. также==
*[[Обход в глубину, цвета вершин]]
*[[Лемма о белых путях]]
==Источники информации==
* [http://e-maxx.ru/algo/bridge_searching MAXimal :: algo :: Поиск мостов]
* [http://en.wikipedia.org/wiki/Bridge_(graph_theory) Wikipedia — Bridge]
* [http://rain.ifmo.ru/cat/view.php/vis/graph-general/biconnected-components-2005| Визуализация поиска мостов]
* ''Седжвик Р.'' Фундаментальные алгоритмы на C++. Часть 5: Алгоритмы на графах. Пер. с англ. — СПб.: ООО «ДиаСофтЮП», 2002. — С. 123-128

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Обход в глубину]]