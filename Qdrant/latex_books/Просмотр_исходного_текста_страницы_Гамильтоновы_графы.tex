[[Файл:Hamiltonial.png|300px|thumb|right|Граф додекаэдра с выделенным циклом Гамильтона]]
==Основные определения==
{{Определение
|definition =
'''Гамильтоновым путём''' (англ. ''Hamiltonian path'') называется простой путь, проходящий через каждую вершину графа ровно один раз.
}}

{{Определение
|id = defCycle
|definition =
'''Гамильтоновым циклом''' (англ. ''Hamiltonian cycle'') называют замкнутый гамильтонов путь.
}}

{{Определение
|definition =
Граф называется '''полугамильтоновым''' (англ. ''Semihamiltonian graph''), если он содержит гамильтонов путь.
}}

{{Определение
|id = hamiltonian_graph
|definition =
Граф называется '''гамильтоновым''' (англ. ''Hamiltonian graph''), если он содержит гамильтонов цикл. 
}}

Очевидно, что любой гамильтонов граф также и полугамильтонов.

==Достаточные условия гамильтоновости графа==

===[[Теорема Дирака|Теорема Дирака]]===
{{Теорема
|statement=
Если n \geqslant 3 и \deg\ v \geqslant n/2 для любой вершины v неориентированного графа G, то G {{---}} гамильтонов граф.
}}

===[[Теорема Оре|Теорема Оре]]===
{{Теорема
|statement=
Если n \geqslant 3 и \deg\ u + \deg\ v \geqslant n для любых двух различных несмежных вершин u и v неориентированного графа G, то G {{---}} гамильтонов граф.
}}

===[[Теорема Поша|Теорема Поша]]===
{{Теорема
|about = Поша
|statement = Пусть граф G имеет n \geqslant 3 вершин и выполнены следующие два условия:

*для всякого k,\, 1 \leqslant k , число вершин со степенями, не превосходящими k, меньше чем k;
*для нечетного n число вершин степени (n-1)/2 не превосходит (n-1)/2, 

тогда G {{---}} гамильтонов граф.
}}
===[[Теорема_Редеи-Камиона|Теорема Редеи-Камиона]]===
{{Теорема
|statement=
Любой сильносвязный [[Турниры|турнир]] {{---}} гамильтонов.
}}

===[[Теорема Гуйя-Ури]]===

{{Теорема
|about=
Ghouila-Houri
|statement=
Пусть G {{---}} сильносвязный ориентированный граф. 

\begin{matrix}
 \deg^+ v \geqslant n/2 \\
 \deg^- v \geqslant n/2 \\

\end{matrix} \Bigg\} \Rightarrow 

 G {{---}} гамильтонов.
}}

===[[Теорема Хватала|Теорема Хватала]]===
{{Теорема
|about=
Хватал
|statement=
Пусть:
* G {{---}} [[Отношение связности, компоненты связности|связный граф]],
* n = |VG| \geqslant 3 {{---}} количество вершин,
* d_1 \leqslant d_2 \leqslant \ldots \leqslant d_n {{---}} его последовательность степеней.
Тогда если \forall k \in \mathbb N верна импликация: 
 d_k \leqslant k 
то граф G [[Гамильтоновы графы|гамильтонов]].
}}

== Задача о коммивояжере ==

Рассмотрим алгоритм нахождения гамильтонова цикла на примере задачи о коммивояжёре.

==== Описание задачи ====
{{Задача
|definition = 
'''Задача о коммивояжере''' (англ. ''Travelling salesman problem, TSP'') — задача, в которой коммивояжер должен посетить N городов, побывав в каждом из них ровно по одному разу и завершив путешествие в том городе, с которого он начал. В какой последовательности ему нужно обходить города, чтобы общая длина его пути была наименьшей?
}}

==== Варианты решения ====

Задача о коммивояжере относится к классу [[NP-полнота задач о гамильтоновом цикле и пути в графах | NP-полных задач]]. Рассмотрим два варианта решения с экспоненциальным временем работы.

===== Перебор перестановок =====
Можно решить задачу перебором всевозможных [[Метод генерации случайной перестановки, алгоритм Фишера-Йетса | перестановок]]. Для этого нужно сгенерировать все N! всевозможных перестановок вершин исходного графа, подсчитать для каждой перестановки длину маршрута и выбрать минимальный из них. Но тогда задача оказывается неосуществимой даже для достаточно небольших N. Сложность алгоритма O({N!}\times{N}).

===== Динамическое программирование по подмножествам (по маскам) =====

Задача о коммивояжере представляет собой поиск кратчайшего гамильтонова цикла в графе.
Зафиксируем начальную вершину s и будем искать гамильтонов цикл наименьшей стоимости — путь от s до s, проходящий по всем вершинам (кроме первоначальной) один раз. Т.к. искомый цикл проходит через каждую вершину, то выбор s не имеет значения. Поэтому будем считать s = 0 .

Подмножества вершин будем кодировать битовыми векторами, обозначим mask_i значение i-ого бита в векторе mask.

Обозначим d[i][mask] как наименьшую стоимость пути из вершины i в вершину 0, проходящую (не считая вершины i) единожды по всем тем и только тем вершинам j, для которых mask_j = 1 (т.е. d[i][mask] уже найденный оптимальный путь от i-ой вершины до 0-ой, проходящий через те вершины, где mask_j=1. Если mask_j=0,то эти вершины еще не посещены).

Алгоритм поиска цикла будет выглядеть следующим образом:

*Начальное состояние — когда находимся в 0-й вершине, ни одна вершина не посещена, а пройденный путь равен 0 (т.е. i = 0 и mask = 0). 
*Для остальных состояний (i \ne 0 или mask \ne 0) перебираем все возможные переходы в i-ую вершину из любой посещенной ранее и выбираем минимальный результат.
*Если возможные переходы отсутствуют, решения для данной подзадачи не существует (обозначим ответ для такой подзадачи как \infty).

Стоимостью минимального гамильтонова цикла в исходном графе будет значение d[0][2^n-1] — стоимость пути из 0-й вершины в 0-ю, при необходимости посетить все вершины. Данное решение требует O({2^n}\times{n}) памяти и O({2^n}\times{n^2}) времени.

Для того, чтобы восстановить сам путь, воспользуемся соотношением d[i][mask] = w(i, j) + d[j][mask - 2^j] , которое выполняется для всех ребер, входящих в минимальный цикл . Начнем с состояния i = 0 , mask = 2^n - 1, найдем вершину j, для которой выполняется указанное соотношение, добавим j в ответ, пересчитаем текущее состояние как i = j, mask = mask - 2^j . Процесс заканчивается в состоянии i = 0, mask = 0 .

===== Поиск любого гамильтонова пути методом динамического программирования =====

Пусть d[mask][i] содержит булево значение — существует ли в подмножестве mask гамильтонов путь, заканчивающийся в вершине i. 

Сама динамика будет такая: 

d[mask][i] = \left\{\begin{array}{llcl}
1&;\ |mask| = 1,\ mask_i = 1\\
\bigvee_{mask[j]=1, (j, i) \in E}\limits d[mask \oplus 2^i][j] &;\ |mask| > 1,\ mask_i= 1 \\
 0&;\ otherwise\\
\end{array}\right.

Это решение требует O(2^nn) памяти и O(2^nn^2) времени. Эту оценку можно улучшить, если изменить динамику следующим образом.

Пусть теперь d'[mask] хранит маску подмножества всех вершин, для которых существует гамильтонов путь в подмножестве mask, заканчивающихся в этой вершине. Другими словами, сожмем предыдущую динамику: d'[mask] будет равно \sum_{i \in [0..n-1]}\limits d[mask][i] \cdot 2 ^i . Для графа G выпишем n масок M_i, для каждой вершины задающие множество вершин, которые связаны ребром с данной вершиной. То есть M_i = \sum_{j \in [0..n-1]}\limits 2^j \cdot ((i, j) \in E ? 1:0) .

Тогда динамика перепишется следующим образом: 

d'[mask] = \left\{\begin{array}{llcl}
mask &;\ |mask| = 1 \\
\sum_{i \in [0..n-1] \& mask_i=1}\limits 2^i \cdot ((d'[mask \oplus 2^i] \& M_i) \neq 0?1:0) &;\ |mask| > 1 \\
 0&;\ otherwise\\
\end{array}\right.

Особое внимание следует уделить выражению d'[mask \oplus 2^i] \& M_i . Первая часть выражения содержит подмножество вершин, для которых существует гамильтонов путь, заканчивающихся в соответствующих вершинах в подмножестве mask без вершины i, а вторая — подмножество вершин, связанных с i ребром. Если эти множества пересекаются хотя бы по одной вершине (их \& не равен 0), то, как нетрудно понять, в mask существует гамильтонов путь, заканчивающийся в вершине i.

Окончательная проверка состоит в сравнении d'[2^n - 1] c 0.

Это решение использует O(2^n) памяти и имеет асимптотику O(2^nn).

==== Псевдокод ====

Прежде чем писать код, скажем пару слов о порядке обхода состояний. Обозначим за |mask| количество единиц в маске (иначе говоря количество пройденных вершин не считая текущей). Тогда, поскольку при рассмотрении состояния \langle i, mask \rangle мы смотрим на состояния

\langle j, mask - 2^j \rangle, и |mask| = |mask - 2^j| + 1, то состояния с большим |mask| должны быть посещены позже, чтобы к моменту вычисления текущего состояния были вычислены все те, которые используются для его подсчёта. 
Однако если использовать рекурсию, об этом можно не беспокоиться (и сэкономить немало кода, времени и памяти).

 // все переменные используются из описания алгоритма, \infty = бесконечность
 '''function''' findCheapest(i, mask):
 '''if''' d[i][mask] != \infty 
 '''return''' d[i][mask] 
 '''for''' j = 0 .. n - 1
 '''if''' w(i, j) существует '''and''' j-ый бит mask == 1 
 d[i][mask] = '''min'''(d[i][mask], findCheapest(j, mask - 2^j) + w(i, j))
 '''return''' d[i][mask]
 
 '''function''' start():
 '''for''' i = 0 .. n - 1
 '''for''' mask = 0 .. 2^n - 1
 d[i][mask] = \infty
 d[0][0] = 0
 ans = findCheapest(0, 2^n - 1)
 '''return''' ans
Дальше ищем сам цикл:
 '''function''' findWay():
 i = 0
 mask = 2^n - 1
 path.push(0)
 '''while''' mask != 0
 '''for''' j = 0 .. n - 1
 '''if''' w(i, j) существует '''and''' j-ый бит mask == 1 '''and''' d[i][mask] == d[j][mask - 2^j] + w(i, j) 
 path.push(j)
 i = j
 mask = mask - 2^j
 '''continue'''

==== Алгоритм нахождения гамильтонова цикла ====
Алгоритм нахождения гамильтонова цикла легко получить слегка изменив алгоритм нахождения минимального гамильтонова цикла.
В массиве d[i][mask] мы хранили расстояния, но сейчас нас не интересует какой длины будет это расстояние, так как главной задачей является нахождение цикла. В этом массиве мы теперь просто храним посещение вершин. И каждый раз, когда при запуске находим непосещенную вершину, то запускаем функцию рекурсивно от нее. Если она возвращает true, то есть до вершины можно добраться, то записываем, что мы можем посетить вершину. Проходы так же осуществляются по рёбрам.

==== Алгоритм нахождения гамильтонова пути ====
Алгоритм нахождения гамильтонова пути легко получить, используя алгоритм нахождения гамильтонова цикла. Нужно добавить в граф еще одну вершину и ребра от нее до всех остальных вершин и из всех остальных вершин до неё. И далее запустить алгоритм поиска цикла от новой вершины. В восстановлении пути учтем, что эта вершина лишняя, и не будем записывать её в путь.

== См. также ==

*[[Кратчайший путь в ациклическом графе]]
*[[Задача о наибольшей общей подпоследовательности]]
*[[Задача о наибольшей возрастающей подпоследовательности]]
*[[Задача о рюкзаке]]
*[[Алгоритм нахождения Гамильтонова цикла в условиях теорем Дирака и Оре]]

==Источники информации==
*Харари Ф. Теория графов: Пер. с англ. / Предисл. В. П. Козырева; Под ред. Г.П.Гаврилова. Изд. 4-е. — М.: Книжный дом "ЛИБРОКОМ", 2009. — 60 с.
*Седжвик Р. Фундаментальные алгоритмы на C++. Алгоритмы на графах. — СПб: ООО «ДиаСофтЮП», 2002.
*[http://ru.wikipedia.org/wiki/Гамильтонов_граф Гамильтонов граф]
*[http://ru.wikipedia.org/wiki/Задача_коммивояжёра Задача коммивояжера в русской википедии]
*[http://de.wikipedia.org/wiki/Problem_des_Handlungsreisenden Задача коммивояжера в немецкой википедии]
*''Романовский И. В.'' Дискретный анализ. СПб.: Невский Диалект; БХВ-Петербург, 2003. ISBN 5-7940-0114-3
*''Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К.'' Алгоритмы: построение и анализ, 2-е издание. М.: Издательский дом "Вильямс", 2005. ISBN 5-8459-0857-4

[[Категория:Алгоритмы и структуры данных]]
[[Категория:Обходы графов]]
[[Категория:Гамильтоновы графы]]
[[Категория:Дискретная математика и алгоритмы]]
[[Категория:Динамическое программирование]]
[[Категория:Классические задачи динамического программирования]]