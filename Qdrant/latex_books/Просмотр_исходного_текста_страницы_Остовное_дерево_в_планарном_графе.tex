В [[Укладка графа на плоскости | планарных графах]] возможно построить [[Остовные деревья: определения, лемма о безопасном ребре | остовное дерево]] за O(n), что заметно быстрее, чем алгоритмы, используемые для поиска остовного дерева в общем случае.
Рассмотрим более общую задачу {{---}} построение остовного дерева минимального (максимального) веса в планарном графе, которая также может быть решена за O(n).
== Остовное дерево минимального (максимального) веса в планарном графе ==
Пусть есть граф G = (V, E), где V – множество вершин, E – множество рёбер. Для произвольной вершины v графа G обозначим как \xi _G(v) множество рёбер графа G, инцидентных v. Для любого подмножества рёбер E'\subseteq E граф (V, E') будем называть остовным лесом графа G, когда граф ацикличен. Остовный лес является остовным деревом, когда он связен. Вес ребра e обозначим как w(e). Вес подмножества рёбер F обозначим как w(F), он является суммой весов рёбер, входящих в F. Максимальный остовный лес F называется остовным лесом минимального (максимального) веса, когда вес w(F) минимален (максимален).
Для решения этой задачи, помимо исходного планарного графа G, потребуется его [[Двойственный граф планарного графа | двойственный граф]] G^* = (V^*, E), который можно легко построить геометрически по укладке G на плоскостиE.L. Lawler, Combinatorial Optimization: Networks and Matroids (Holt, Rinehart and Winston, New York, 1976).

Если данный граф связен, задача эквивалентна обычной задаче поиска минимального (максимального) по весу остовного дерева. Известно, что подмножество рёбер T\subseteq E – максимальный остовный лес G тогда и только тогда, когда E\setminus T – максимальный остовный лес G^*. Таким образом, задача поиска минимального по весу остовного леса графа G – по сути то же самое, что задача поиска максимального по весу остовного леса G^*.
== Формальное описание алгоритма ==
Итак, имеется планарный граф G = (V, E), его двойственный граф G^* = (V^*, E) и веса рёбер w, на выходе нужно получить остовный лес минимального веса T графа G и остовный лес максимального веса T^* графа G^*.

'''Шаг 0''': Запись графов. T := \varnothing; T^* := \varnothing.

'''Шаг 1''': Если графы G и G^* пусты одновременно, выведем T и T^*.

'''Шаг 2''': Выберем вершину v в графе G или G^*:

Если v – изолированная вершина, удалим её и вернёмся к шагу 1; 

Если v – вершина G и в \xi _G(v) есть петля, перейдём к шагу 3;

Если v – вершина G и в \xi _G(v) нет петель, перейдём к шагу 4;

Если v – вершина G^* и в \xi _{G^*}(v) есть петля, перейдём к шагу 5;

Если v – вершина G^* и в \xi _{G^*}(v) нет петель, перейдём к шагу 6;

'''Шаг 3''': Пусть f – петля G, инцидентная v.
 
G := G\setminus f; G* := G*\setminus f; T* := T*\cup \{f\}.
 
Вернёмся к шагу 1.

'''Шаг 4''': Найдём ребро e, достигающее минимального веса w(e) среди рёбер из \xi _G(v).

G := G/e; G^* := G^*\setminus e; T := T\cup \{e\}. (/ обозначает операцию стягивания ребра)

Вернёмся к шагу 1.

'''Шаг 5''': Пусть f – петля G^*, инцидентная v.
 
G := G\setminus f; G^* := G^*\setminus f; T := T\cup\{f\}.
 
Вернёмся к шагу 1.

'''Шаг 6''': Найдём ребро e, достигающее максимального веса w(e) среди рёбер из \xi _{G^*}(v).

G\setminus e; G^*/e; T^*:= T^*\cup\{e\}.

Вернёмся к шагу 1.
== Корректность и время работы ==
Легко убедиться в том, что на протяжении всех итераций приведённого алгоритма G^* является двойственным графом графа G, из чего следует корректность этого алгоритма.

На каждой итерации алгоритма происходит удаление ребра или вершины, из этого следует, что количество итераций алгоритма не превосходит |V| + |V^*| + |E| = O(n).

Далее опишем, как добиться того, чтобы каждая итерация осуществлялась за O(1). Для каждой вершины v графа G обозначим d_G(v) степень этой вершины (петли считаются дважды). Из формулы Эйлера следует, что в G или G^*, где G – планарный граф, а G^* - двойственный к нему, существует вершина, степень которой меньше четырёх.

На шаге 2 будем выбирать именно такую вершину. Сначала покажем, что каждая интеграция алгоритма выполняется за O(n), предполагая, что нужная вершина на шаге 2 всегда выбирается за константное время, реализацию обсудим позже.

Итак, оба графа хранятся в виде списков смежности. Тогда, очевидно, шаги 1 и 2 выполняются за O(1). Поскольку при такой реализации рёбра удаляются за константное время, шаги 3 и 5 выполняются за O(1). Рассмотрим шаг 4. Поскольку степень вершины не больше четырёх, поиск ребра минимального веса займёт константное время. Стягивание ребра e = (u, v) происходит за O(\min\{d_G(v), d_G(u)\}) = O(3) = O(1). Для шага 6 рассуждения аналогичны.

Вернёмся к выбору вершины на шаге 2. Для этого создадим хэш-таблицу, содержащую все вершины степени меньше четырёх. Это позволяет выбрать нужную вершину за O(1), но хэш-таблицу также нужно обновлять. При удалении ребра из графа степени вершин, инцидентных ему, уменьшаются на 1 (или на 2 в случае петли), степени же остальных вершин не меняются. Теперь рассмотрим случай стягивания ребра. Удаляются концы стягиваемого ребра, а получающаяся в результате этого вершина должна быть добавлена в хэш-таблицу, если её степень меньше четырёх. Таким образом, на каждой итерации алгоритма из хэш-таблицы может быть удалено максимум две вершины, а добавлено - максимум четыре, значит, хэш-таблица обновляется за константное время.
Создание хэш-таблицы должно происходить вместе с шагом 0 и осуществляется за O(|V| + |V^*| + |E|).
== Примечания ==

== Источники информации ==
[http://www.sciencedirect.com/science/article/pii/0166218X9400095U Sciencedirect {{---}} The minimum spanning tree problem on a planar graph]