Рассмотрим несколько задач, которые решаются путём сведения к задаче о поиске максимального потока в сети.

== Пример №1. Лабиринт Минотавра ==
{{Задача
|definition = Дано поле размером N \times M, некоторые клетки поля закрашены. В одной из незакрашенных клеток поля стоит Минотавр, он умеет ходить только по незакрашенным клеткам (из текущей клетки он может пойти только в ту клетку, с которой имеет общую сторону). Какое минимальное количество клеток нужно закрасить, чтобы Минотавр не смог выбраться за пределы поля?
}}
{{#if: {{{neat|}}}|

'''Задача:'''
{{{definition}}}
|

'''Задача:'''
{{{definition}}}
}}

[[Файл:Monster.png|Пример поля]] [[Файл:MonsterSolution.png|Решение текущего примера]]

Сразу скажем, что выбраться за пределы поля эквивалентно тому, что Минотавр может дойти до какой-либо крайней клетки.

=== Решение и доказательство корректности ===

{{Теорема
|statement=
Минимальное количество клеток, которое нужно закрасить, равно максимальному количеству клеточно-непересекающихся путей из позиции Минотавра до крайних клеток поля.
|proof=
Очевидно, что ответ не больше, чем количество всех путей от Минотавра до крайних клеток. Сделаем ещё более строгое неравенство: ответ не больше, чем максимальное количество клеточно-непересекающихся путей, т.к. если взять какие-нибудь 2 пересекающихся пути и закрасить клетку в позиции, где они пересекаются, то блокируется выход за пределы поля сразу по 2 этим путям. С другой стороны, если закрасить клетку на каком-то из путей, то блокируется только этот путь, т.к. были взяты клеточно-непересекающиеся пути. Значит, ответ не меньше, чем количество таких путей.
}}

=== Переход к сети ===

Рассмотрим [[Определение сети, потока#flow_network|сеть]], в которой вершинам будут соответствовать незакрашенные клетки поля, соседние незакрашенные клетки соединим ориентированными рёбрами с пропускной способностью 1. В качестве истока возьмём вершину, которой соответствует клетка Минотавр. Добавим в граф ещё одну вершину — сток, добавим рёбра из вершин, соответствующим крайним клеткам поля, в сток с пропускной способностью 1. Чтобы пути не пересекались по клеткам, раздвоим каждую вершину графа на 2 вершины: в одну будут только входить рёбра, из другой — только выходить рёбра, и сами эти вершины соединим ребром с пропускной способностью 1. 

[[Файл:Dublicate2.png|center]]

Используя [[Алгоритм Форда-Фалкерсона, реализация с помощью поиска в глубину|алгоритм Форда-Фалкерсона]], найдём максимальный поток в сети. Согласно [[Теорема о декомпозиции|теореме о декомпозиции]], нахождение максимального потока эквивалентно тому, что мы нашли максимальное количество путей из истока в сток. Т.е. требуемый ответ на задачу равен максимальному потоку. 

=== Оценка времени работы ===

Время работы алгоритма Форда-Фалкерсона O(E|f|). Первое замечание: E \leqslant 4V \leqslant 4NM (это следует из того, что из каждой вершины исходит не более 4 рёбер), т.е. E=O(NM). Второе замечание: ответ не превосходит 4, т.к. можно закрасить клетку слева, справа, сверху и снизу от позиции Минотавра и он не сможет никуда двигаться, поэтому |f| можно считать константой. Итоговое время работы O(NM).

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Задача о максимальном потоке ]]

==Пример №2. Испорченный паркет.==
{{Задача
|definition = Дан паркет размером N \times M, некоторые клетки которого испорчены, их необходимо закрыть новыми плитками. Плитки бывают размером 2 \times 1 ценой A, и 1 \times 1 ценой B. Плитки можно поворачивать, но нельзя разрезать. Какую минимальную сумму нужно потратить, чтобы заложить испорченные плитки паркета. Новые плитки не должны перекрывать никакие другие плитки.
}}
===Решение===
{| cellpadding="3" style="margin-left: auto; margin-right: auto;"
| [[Файл:Parquet_example_1.png|thumb|400px|Пример паркета]]
| [[Файл:Parquet_example_2.png|thumb|400px|Пример раскраски]]
|}
Сначала проверим, что 2 \times B>A. Если это условие не выполнено, то все выгодней замостить только плитками 1 \times 1 и больше нечего считать. Теперь на нужно максимизировать количество плиток ценой A.
Раскрасим наш паркет по принципу шахматной доски, тогда один конец плитки 2 \times 1 будет лежать на черной клетке, другой – на белой. Итак, построим двудольный граф, одна доля которого будет содержать белые клетки, другая – черные. Ребра весом в 1 проведем между граничащими клетками. Добавим исток с ребрами в белые вершины весом в 1 и сток с ребрами из черных клеток весом тоже в 1. Пускай f – величина найденного максимального потока между истоком и стоком, это и будет количество плиток 2 \times 1. Ответом к задаче будет величина f \times A+(K-f) \times B, где K – общее число испорченных клеток.

===Доказательство корректности===
Заметим следующее: мы ищем максимальное паросочетание в двудольном графе. Это означает, что белая вершина будет соединена не более чем с одной чёрной и наоборот – это именно то, что нам нужно, ведь соединяя чёрную клетку с белой, мы понимаем, что можем разместить здесь плитку размером 2 \times 1 и она не будет ни с чем пересекаться. Теперь мы ищем максимальное число таких рёбер. Это всё происходит также, как и в сведении задачи поиска максимального паросочетания к задаче о нахождении максимального потока.
=== Оценка времени работы ===

Величину максимального потока можно искать с помощью алгоритма Форда-Фалкерсона, его время работы O(E|f|), где |f| – величина найденного максимального потока. Заметим, что |f| \leqslant \dfrac K 2, где K – общее число испорченных клеток. Также заметим, что E \leqslant K \times 4, т.к. K рёбер исходят из истока и входят в сток и максимум 4 ребра могут исходить из вершины в левой доле в правую. Из всего этого следует, что итоговое время работы будет O(K^2)

==Пример №3. Коллекционер монет.==
{{Задача
|definition=Есть N коллекционеров и M видов монет. Для вступления в клуб, необходимо иметь не меньше одной монеты каждого типа. Вы (у вас номер 1) можете меняться с коллекционерами имеющимися монетами. Любой коллекционер обменяет свою монету a на вашу монету b, если у него '''больше''' одной монеты типа a и нету ни одной монеты типа b. Вы, в свою очередь, можете нарушать это правило. Нужно набрать как можно больше типов монет по известной ситуации у всех коллекционеров.
}}
===Решение===
[[Файл:Coints_task.gif|400px|thumb|right|Жёлтые вершины – монеты разных типов, синие – коллекционеры. Красное ребро означает, что коллекционеру нужна монета этого типа, причём пропускная способнасть этого ребра равна 1, зелёное – что у него больше одной монеты данного типа]]
Построим сеть следующего вида: создадим для каждого типа монет по одной вершине, эти вершины будут соответствовать вашим монетам. Нужно собрать как можно больше уникальных монет, поэтому проведем ребро пропускной способности 1 в сток из каждой такой вершины. В вершины, соответствующие монетам, которые у Вас есть изначально, проведем ребро, пропускная способность которого равна количеству таких монет у вас. Для каждого члена клуба (кроме вас) заведем по одной вершине. Эта вершина может принимать не более одной монеты, которой у него нет и отдавать не более k-1 монеты, которых у него k (k > 1). Естественно, член клуба отдает одну монету взамен одной полученной. Таким образом, в каждую такую вершину нужно провести ребро пропускной способности 1 из вершин соответствующих монетам, которых нет у этого члена клуба. А из этих вершин нужно провести ребра пропускной способностью k_i - 1 в вершину i, соответствующую монетам, которых у члена клуба больше одной. Построенная сеть отражает процессы обмена в клубе. Максимальный поток в такой сети будет равен максимальному количеству монет, которые могуть быть собраны вами.
===Доказательство корректности===
Как уже было сказано, построенная сеть отражает процессы обмена в клубе, пример можно посмотреть на картинке выше. Заметим следующее: 
* из вершины каждого типа монет может выйти поток, величина которого \leqslant 1 
* в вершины каждого типа монет может войти поток, величина которого не больше количества монет данного типа
* если коллекционеру нужна эта монета и мы решили дать её, то мы дадим максимум одну монету этого типа, т.к. пропускная способность красного ребра = 1.
* если в данную вершину пришёл поток данной величины, то мы должны отдать из этой вершины поток такой же величины. (Из определения потока)
Всё вышесказанное подтверждает то, что построенная сеть корректно отображает процессы обмена монетами между участниками. 
=== Оценка времени работы ===

Величину максимального потока можно искать с помощью алгоритма Форда-Фалкерсона, его время работы O(E|f|), где |f| – величина найденного максимального потока. Заметим, что |f| \leqslant M, где M – количество типов монет. Также заметим, что E = M \times 2 + E^*, где E^* – общее минимальное число монет, которые нужно получить все коллекционерам (кроме вас), чтобы вступить в клуб + сумма типов монет, которых больше 1, по всем коллекционерам. Из всего этого следует, что итоговое время работы будет O(ME)

== См.также ==
* [[Схема алгоритма Диница]]
* [[Алгоритм Форда-Фалкерсона, реализация с помощью поиска в глубину]]
* [[Алгоритм масштабирования потока]]

== Источники информации ==
* [https://icpc.baylor.edu/regionals/finder/west-siberian-subregional-2016 The 2016 West Siberian Subregional Contest]
* [https://www.dropbox.com/s/o24szu3mj341wig/WPS2009.pdf?dl=0 Зимняя школа по программированию, Харьков 2009 ]
* [http://codeforces.com/blog/entry/19068?locale=ru Codeforces лекции Зимней Школы по Программированию]