{{Задача
|definition=Определить, является ли граф планарным, и, если да, произвести его плоскую укладку.
}}
Существует [[Теорема Понтрягина-Куратовского|теорема Понтрягина-Куратовского]], которая говорит, что граф планарен тогда и только тогда, когда он не содержит подграфов, гомеоморфных K_{5} или K_{3, 3} . Но этот критерий очень трудно проверить на практике, поэтому данная теорема представляет лишь теоретический интерес.

Чтобы проверить планарность графа и произвести его плоскую укладку, удобно пользоваться гамма-алгоритмом.

== Входные данные ==

На вход алгоритму подаются графы со следующими свойствами:
# Граф [[Отношение связности, компоненты связности|связный]].
# Граф содержит хотя бы один цикл.
# Граф не имеет [[Мост, эквивалентные определения|мостов]].

Если нарушено свойство 1, то граф нужно укладывать отдельно по компонентам связности. Если нарушено свойство 2, то граф {{---}} дерево и [[Укладка дерева|нарисовать его плоскую укладку]] тривиально. 

Более подробно рассмотрим случай, когда в графе G нарушено свойство 3. Сначала все мосты нужно убрать, далее произвести отдельную укладку всех компонент следующим образом: уложим одну компоненту связности, а следующую компоненту, связанную с первой в графе G мостом, будем рисовать в той грани, в которой лежит вершина, принадлежащая мосту. Иначе может сложиться ситуация, когда концевая вершина моста будет находиться внутри плоского графа, а следующая компонента {{---}} снаружи. Таким образом мы сможем соединить мостом нужные вершины. Далее будем так поступать с каждой новой компонентой.

== Описание алгоритма ==

Рассмотрим работу алгоритма, параллельно разбирая на примере каждый шаг.
Пусть дан граф G (рис. 1).

{| cellpadding="2"
| || [[Файл:Гамма-алгоритм1.jpg|thumb|left|370px|Рис. 1. Исходный граф.]]
|}

=== Инициализация ===

Первый этап {{---}} '''инициализация''' алгоритма. 

В графе G выбирается [[Использование обхода в глубину для поиска цикла|любой простой цикл]] и производится его укладка на плоскость. Пусть в примере это будет цикл \{1, 2, 3, 4, 5, 6\}. После его укладки получаем две грани: \Gamma_{1} и \Gamma_{2} (рис. 2).

{| cellpadding="2"
| || [[Файл:Гамма-алгоритм2.jpg|thumb|left|370px|Рис. 2. Укладка цикла на плоскость.]]
|}

Уже уложенную во время работы алгоритма часть будем обозначать G_{plane}. В примере сейчас G_{plane} {{---}} выбранный цикл \{1, 2, 3, 4, 5, 6\}.

=== Общий шаг ===

Второй этап {{---}} общий шаг.

Построим множество '''сегментов'''. Каждый сегмент S относительно уже построенного G_{plane} представляет собой одно из двух:
# ребро, оба конца которого принадлежат G_{plane}, но само оно не принадлежит G_{plane},
# связную компоненту графа G \backslash G_{plane}, дополненную всеми ребрами графа G такими, у которых один из концов принадлежит связной компоненте, а второй принадлежит графу G_{plane}.

Вершины, одновременно принадлежащие G_{plane} и какому-либо сегменту, назовем '''контактными'''. На рис. 3 изображены сегменты для нашего примера. Контактные вершины обведены в квадрат.

{| cellpadding="2"
| || [[Файл:Гамма-алгоритм3.jpg|thumb|left|370px|Рис. 3. Выделение сегментов.]]
|}

Пусть в каком-то сегменте нет ни одной контактной вершины. В таком случае граф до выделения G_{plane} был несвязным, что противоречит условию. Пусть контактная вершина в сегменте только одна. Это значит, что в графе был мост или точка сочленения, чего быть не может так же по условию. Таким образом, в каждом сегменте имеется не менее двух контактных вершин. Соответственно, в каждом сегменте есть цепь между любой парой контактных вершин.

Пусть грань \Gamma '''вмещает''' сегмент S, если номера всех контактных вершин S принадлежат этой грани, S \subset \Gamma. Очевидно, таких граней может быть несколько. Множество таких граней обозначим \Gamma(S), а их число {{---}} |\Gamma(S)|.

Итак, рассмотрим все сегменты S_{i} и для каждого определим число |\Gamma(S_{i})|. Если найдется такой номер i, что |\Gamma(S_{i})| = 0, то граф не планарен, алгоритм завершает работу. Иначе выбираем такой сегмент S_{i}, для которого число |\Gamma(S_{i})| минимально. Если таких сегментов несколько, можно выбрать любой из них. Найдем в этом сегменте цепь между двумя контактными вершинами и уложим ее в любую грань из множества \Gamma(S_{i}), совместив контактные вершины сегмента с соответствующими вершинами грани. Выбранная грань разобьется на две. Выбранный сегмент после того, как из него взяли цепь, либо исчезнет, либо распадется на меньшие части, в которых будут новые контактные вершины, ведущие к вершинам обновленного G_{plane}.

В примере для любого i: S_{i} \subset \{\Gamma_{1}, \Gamma_{2}\}, то есть |\Gamma(S_{i})| = 2. Следовательно, можем выбрать любой S_{i}. Пусть это будет сегмент S_{1}. В нем есть цепь \{1, 4\}. Вставим эту цепь в грань \Gamma_{1}, например, и этот сегмент исчезнет. После укладки цепи граф G и сегменты будут выглядеть так (рис. 4):

{| cellpadding="2"
| || [[Файл:Гамма-алгоритм4.jpg|thumb|left|500px|Рис. 4. Граф и сегменты после второго этапа.]]
|}

Третий и последующие этапы аналогичны второму. Повторять вышеуказанные действия нужно либо до тех пор, пока не будет получена плоская укладка, то есть множество сегментов не останется пустым, либо пока не будет получено, что граф не планарен. 

Разберем пример до конца. Повторим снова общий шаг. Теперь |\Gamma(S_{1})| = |\Gamma(S_{3})| = 1, |\Gamma(S_{2})| = |\Gamma(S_{4})| = 2. Возьмем S_{1}. В ней цепь \{2, 5\}, которую мы уложим в грань \Gamma_{2}, после чего этот сегмент исчезнет. Теперь картина будет следующая (рис. 5):

{| cellpadding="2"
| || [[Файл:Гамма-алгоритм5.jpg|thumb|left|500px|Рис. 5. Граф и сегменты после третьего этапа.]]
|}

На следующем шаге |\Gamma(S_{1})| = |\Gamma(S_{3})| = 2, |\Gamma(S_{2})| = 1. Выбираем сегмент S_{2}, содержащий цепь \{3, 5\}. Уложим ее в грань \Gamma_{2}, после чего этот сегмент снова исчезнет (рис. 6). 

{| cellpadding="2"
| || [[Файл:Гамма-алгоритм6.jpg|thumb|left|500px|Рис. 6. Граф и сегменты после четвертого этапа.]]
|}

Теперь |\Gamma(S_{1})| = 1, а |\Gamma(S_{3})| = 2. Уложим сначала цепь \{2, 4\} из первого сегмента, он пропадет, потом уложим цепь \{6, 7, 5\} из третьего. В результате граф будет полностью уложен на плоскость, множество сегментов останется пустым (рис. 7).

{| cellpadding="2"
| || [[Файл:Гамма-алгоритм7.jpg|thumb|left|300px|Рис. 7. Плоская укладка графа.]]
|}

Таким образом, мы получили плоскую укладку исходного графа G.

Опишем алгоритм коротко и формально:
# Инициализация. Выбирается простой цикл в исходном графе и изображается на плоскости. 
# Общий шаг. Этот шаг повторяется до тех пор, пока граф не будет уложен или пока не будет получено, что граф не планарен. 
#* строится множество сегментов
#* для каждого сегмента вычисляется величина |\Gamma(S)|. Если существует i: |\Gamma(S_{i})| = 0, то граф не планарен, алгоритм завершает работу
#* выбирается сегмент с минимальным числом |\Gamma(S_{i})|
#* в этом сегменте выбирается цепь между двумя контактными вершинами 
#* эта цепь укладывается в любую грань, вмещающую данный сегмент
# Либо получена плоская укладка графа, либо граф оказался не планарен.

== Доказательство корректности гамма-алгоритма ==

Перед доказательством корректности приведем ряд важных вспомогательных лемм. 

Пусть два сегмента S_{1} и S_{2} называются '''конфликтующими''' относительно уже уложенной части, если:
# грань вмещает каждый из сегментов S_{1} и S_{2}
# в этих сегментах есть две цепи между контактными вершинами L_{1} и L_{2} соответственно такие, что их невозможно уложить в одну грань без пересечения

Например, на рис. 1 конфликтующими являются сегменты S_{1} и S_{2}. 

{| cellpadding="2"
| || [[Файл:Гамма-алгоритм8.jpg|thumb|left|520px|Рис. 1. Конфликтующие сегменты.]]
|}

{{Лемма
|id=lemma1
|about=1
|statement=Конфликтующие сегменты S_{1} и S_{2} обладают следующим свойством: если |\Gamma(S_{1})| \geqslant 2 и |\Gamma(S_{2})| \geqslant 2, то \Gamma(S_{1}) = \Gamma(S_{2}) = 2.

|proof=Сначала докажем, что \Gamma(S_{1}) = \Gamma(S_{2}). Предположим противное. Тогда по условию леммы найдутся три различные грани \Gamma_{1}, \Gamma_{2} и \Gamma_{3} такие, что \Gamma_{1} \in \Gamma(S_{1}), \Gamma_{2} \in \Gamma(S_{2}), \Gamma_{3} \in Q = \Gamma(S_{1}) \cap \Gamma(S_{2}) \neq \emptyset. Тогда любые цепи L_{1} \subset S_{1} и L_{2} \subset S_{2} укладываются в \Gamma_{1} и \Gamma_{2} соответственно. Но это значит, что любая пара цепей L_{1} и L_{2} одновременно укладывается вне грани \Gamma_{3}. Следовательно, они одновременно укладываются и внутри грани \Gamma_{3}, причем без пересечений. Но это противоречит тому, что S_{1} и S_{2} {{---}} конфликтующие сегменты. Таким образом, \Gamma(S_{1}) = \Gamma(S_{2}).

Теперь покажем, что |Q| = 2. Доказательство снова поведем методом от противного. Пусть |Q| \geqslant 3. Тогда снова существует три различные грани \Gamma_{1}, \Gamma_{2} и \Gamma_{3} \in Q. Аналогичными рассуждениями снова приходим к противоречию с тем, что S_{1} и S_{2} {{---}} конфликтующие сегменты. 
}}

'''Замечание.''' Пусть имеется множество сегментов таких, что они удовлетворяют следующей схеме: есть первый сегмент S_{1}, второй S_{2}, который конфликтует с S_{1}, третий S_{3}, который конфликтует с S_{2}, но не с S_{1}, и так далее, причем каждый из них укладывается в две грани. Тогда из леммы 1 следует, что эти грани являются общими для всех сегментов множества и можно укладывать их следующим образом: цепь L_{1} \subset S_{1} укладывается в первую грань \Gamma_{1}, цепь L_{2} \subset S_{2} {{---}} во вторую \Gamma_{2}, L_{3} \subset S_{3} {{---}} снова в \Gamma_{1} и так для всех элементов множества. Если цепочка сегментов замыкается в цикл четной длины, то проблем никаких нет. Если длина цикла нечетная, то два последних конфликтующих сегмента нужно будет уложить в одну грань без пересечений, что по определению невозможно. Следовательно, получить плоскую укладку нельзя.

{{Определение
|definition =
'''Частичной укладкой''' G' планарного графа G называется граф, который можно получить из какой-либо укладки графа G на плоскости путем удаления некоторых ребер и вершин.
}}

Таким образом во всякую частичную укладку планарного графа G можно уложить оставшуюся часть, а именно недостающие вершины и ребра графа G.

Построим некоторый '''служебный граф''' A(G') по следующей схеме: каждому сегменту в G' сопоставим некоторую вершину в A(G'), причем две вершины будут смежны тогда и только тогда, когда соответствующие им сегменты являются конфликтующими.

Например, для графа на рис. 1 служебный граф будет иметь вид (рис. 2):

{| cellpadding="2"
| || [[Файл:Гамма-алгоритм9.jpg|thumb|left|220px|Рис. 2. Служебный граф. Вершины обозначены как соответствующие сегменты.]]
|}

{{Лемма
|id=lemma2
|about=2
|statement=Если результатом некоторого шага работы гамма-алгоритма является частичная укладка G' планарного графа G такая, что |\Gamma(S)| \geqslant 2 для любого сегмента S относительно G', то A(G') {{---}} [[Двудольные графы и раскраска в 2 цвета|двудольный граф]].

|proof=Докажем от противного. Пусть A(G') {{---}} не двудольный. Тогда по [[Двудольные графы и раскраска в 2 цвета#Теорема Кенига|теореме Кенинга]] в нем есть цикл нечетной длины. Этому циклу соответствует некоторая последовательность сегментов S_{1}, S_{2}, \cdots S_{2m+1}, S_{1} относительно G', в которой каждые соседние сегменты конфликтующие по определению. По лемме 1 \Gamma(S_{i}) = \{\Gamma_{1}, \Gamma_{2}\}, i \in \{1 \cdots 2m+1\}. Так как G' {{---}} частичная укладка графа, то все сегменты S_{1}, S_{2}, \cdots S_{2m+1} могут быть уложены. А так как соседние сегменты этой последовательности конфликтующие, то они должны быть уложены в разные грани, что невозможно, так как число сегментов в последовательности нечетное. Получили противоречие. Следовательно, A(G') {{---}} двудольный.
}}

{{Теорема 
|about=
О корректности гамма-алгоритма
|statement=
Гамма-алгоритм корректен, то есть если G {{---}} планарный граф, то результатом каждого шага гамма-алгоритма является частичная укладка G'.
|proof=Докажем индукцией по числу шагов. 

'''База индукции:''' полученный на этапе инициализации граф G'_{0} является простым циклом, он будет присутствовать в любой укладке графа G. Таким образом, G'_{0} является частичной укладкой. 

'''Шаг индукции:''' пусть граф G'_{k-1}, полученный на k-1-м шаге работы алгоритма, является частичной укладкой. Докажем, что граф G'_{k} = G'_{k-1} \cup L_{k}, полученный на k-м шаге присоединением цепи L_{k}, также является частичной укладкой.

Заметим, что на текущем шаге нет такого сегмента S относительно G'_{k-1}, для которого бы выполнялось равенство \Gamma(S) = \emptyset, так как в противном случае существовала бы цепь этого сегмента, контактные вершины которой принадлежали бы разным граням и укладка которой была бы невозможна. Следовательно, нельзя было бы уложить S,что противоречит тому, что G {{---}} планарный граф. Значит, мы можем рассматривать только следующие два случая: 

1. Существует сегмент S для которого есть единственная вмещающая грань \Gamma, то есть |\Gamma(S)| = 1. Так как только грани \Gamma принадлежат все контактные вершины S, то укладка этого сегмента в эту грань неизбежна. Это значит, что помещая любую цепь L \subset S, снова получим частичную укладку графа.

2. Для любого сегмента S |\Gamma(S)| \geqslant 2. Построим граф A(G'_{k-1}), который по лемме 2 является двудольным. Рассмотрим его связную компоненту K, которая содержит не менее двух вершин. Граф K также является двудольным. По лемме 1 для любого сегмента S \in K справедливо \Gamma(S) = \{\Gamma_{1}, \Gamma_{2}\}. Так как граф K двудольный, то мы можем по очереди помещать сегменты K в разные грани, причем конфликтующих сегментов не возникнет в силу четности всех циклов в графе. Результатом будет частичная укладка графа.

Таким образом, на каждом шаге мы получаем частичную укладку графа, что доказывает корректность гамма-алгоритма.
}}

'''Следствие:''' Если граф G планарный, то гамма-алгоритм строит его плоскую укладку.

'''Следствие:''' Если на каком-то шаге встретился сегмент S, для которого нет вмещающей грани, то граф непланарный.

==См. также==
* [[Теорема Понтрягина-Куратовского|Теорема Понтрягина-Куратовского]]
* [[Теорема Фари|Теорема Фари]]

== Источники информации ==
* [http://rain.ifmo.ru/cat/view.php/theory/graph-coloring-layout/layout-2004 Дискретная математика: алгоритмы]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Укладки графов ]]