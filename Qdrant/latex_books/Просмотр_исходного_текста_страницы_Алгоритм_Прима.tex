'''Алгоритм Прима''' (англ. ''Prim's algorithm'') — алгоритм поиска [[Лемма о безопасном ребре#Минимальное остовное дерево|минимального остовного дерева]] (англ. ''minimum spanning tree, MST'') во взвешенном [[Основные определения теории графов#Неориентированные графы | неориентированном связном графе]].

== Идея ==
Данный алгоритм очень похож на [[алгоритм Дейкстры]]. Будем последовательно строить поддерево F ответа в графе G, поддерживая [[Дискретная_математика,_алгоритмы_и_структуры_данных#.D0.9F.D1.80.D0.B8.D0.BE.D1.80.D0.B8.D1.82.D0.B5.D1.82.D0.BD.D1.8B.D0.B5_.D0.BE.D1.87.D0.B5.D1.80.D0.B5.D0.B4.D0.B8 | приоритетную очередь]] Q из вершин G \setminus F, в которой ключом для вершины v является \min\limits_{u \in V(F), uv \in E(G)}w(uv) — вес минимального ребра из вершин F в вершины G \setminus F. Также для каждой вершины в очереди будем хранить p(v) — вершину u, на которой достигается минимум в определении ключа. Дерево F поддерживается неявно, и его ребра — это пары \left(v,p(v)\right), где v \in G \setminus \{r\} \setminus Q, а r — корень F. Изначально F пусто и значения ключей у всех вершин равны +\infty. Выберём произвольную вершину r и присвоим её ключу значение 0. На каждом шаге будем извлекать минимальную вершину v из приоритетной очереди и релаксировать все ребра vu, такие что u \in Q, выполняя при этом операцию \text{decreaseKey} над очередью и обновление p(v). Ребро \left(v,p(v)\right) при этом добавляется к ответу.

== Реализация ==
 // G {{---}} исходный граф
 // w {{---}} весовая функция
 '''function''' \mathtt{primFindMST}():
 '''for''' v \in V(G)
 \mathtt{key}[v]\ =\ \infty
 \mathtt{p}[v]\ = ''null''
 r\ = произвольная вершина графа G
 \mathtt{key}[r]\ =\ \mathtt{0} 
 Q.\mathtt{push}(V(G)) 
 '''while not''' Q.\mathtt{isEmpty()}
 v\ =\ Q.\mathtt{extractMin}() 
 '''for''' vu \in E(G)
 '''if''' u \in Q '''and''' \mathtt{key}[u] > w(v, u)
 \mathtt{p}[u]\ =\ v
 \mathtt{key}[u]\ =\ w(v, u)
 Q.\mathtt{decreaseKey}(u, \mathtt{key}[u])

Ребра дерева восстанавливаются из его неявного вида после выполнения алгоритма.
Чтобы упростить операцию \mathrm{decreaseKey} можно написать кучу на основе [[АВЛ-дерево | сбалансированного бинарного дерева поиска]]. Тогда просто удалим вершину и добавим ее обратно уже с новым ключом. Асимптотика таких преобразований O(\log n). Если же делать с [[Двоичная_куча | бинарной кучей]], то вместо операции \mathrm{decreaseKey}, будем всегда просто добавлять вершину с новым ключом, если из кучи достали вершину с ключом, значение которого больше чем у нее уже стоит, просто игнорировать. Вершин в куче будет не больше n^2, следовательно, операция \mathrm{extractMin} будет выполняться за O(\log n^2), что равно O(\log n). Максимальное количество вершин, которое мы сможем достать, равняется количеству ребер, то есть m, поэтому общая асимптотика составит O(m \log n), что хорошо только на разреженных графах.

==Пример==
Рассмотрим работу алгоритма на примере графа.
Пусть произвольно выбранная вершина — это вершина a.
{| cellpadding = "20" class = "wikitable"
! Изображение !! Множество вершин !! Описание
|-
|[[Файл:Mst_prima_1.png|200px]]
|
{| width="100%" style = "text-align: center"
| '''a''' || '''b''' || '''c''' || '''d''' || '''e'''
|-
| 0 || \infty || \infty || \infty || \infty
|}
|style="padding-left: 1em" | Извлечём из множества вершину '''a''', так как её приоритет минимален.Рассмотрим смежные с ней вершины '''b''', '''c''', и '''e'''. Обновим их приоритеты, как веса соответствующих рёбер '''ab''', '''ac''' и '''ae''', которые будут добавлены в ответ.
|-
|[[Файл:Mst_prima_2.png|200px]]
|
{| width="100%" style = "text-align: center"
| a || '''b''' || '''c''' || '''d''' || '''e'''
|-
| 0 || 3 || 4 || \infty || 1 
|}
|style="padding-left: 1em" |Теперь минимальный приоритет у вершины '''е'''. Извлечём её и рассмотрим смежные с ней вершины '''a''', '''c''', и '''d'''.Изменим приоритет только у вершины '''d''', так как приоритеты вершин '''a''' и '''с''' меньше,чем веса у соответствующих рёбер '''ea''' и '''ec''', и установим приоритет вершины '''d''' равный весу ребра '''ed''', которое будет добавлено в ответ.
|-
|[[Файл:Mst_prima_3.png|200px]]
|
{| width="100%" style = "text-align: center"
| a || '''b''' || '''c''' || '''d''' || e
|-
| 0 || 3 || 4 || 7 || 1 
|}
|style="padding-left: 1em" |После извлечения вершины '''b''' ничего не изменится, так как приоритеты вершин '''a''' и '''с''' меньше,чем веса у соответствующих рёбер '''ba''' и '''bc'''. Однако, после извлечения следующей вершины {{---}} '''c''',будет обновлён приоритет у вершины '''d''' на более низкий (равный весу ребра '''cd''') и в ответе ребро '''ed''' будет заменено на '''cd'''.
|-
|[[Файл:Mst_prima_4.png|200px]]
|
{| width="100%" style = "text-align: center"
| a || b || c || '''d''' || e
|-
| 0 || 3 || 4 || 2 || 1 
|}
|style="padding-left: 1em" |Далее будет рассмотрена следующая вершина {{---}} '''d''', но ничего не изменится,так как приоритеты вершин '''e''' и '''с''' меньше, чем веса у соответствующих рёбер '''de''' и '''dc'''.После этого алгоритм завершит работу, так как в заданном множестве не останется вершин,которые не были бы рассмотрены
|}

== Корректность ==
По поддерживаемым инвариантам после извлечения вершины v\ (v \neq r) из Q ребро \left(v,p(v)\right) является ребром минимального веса, пересекающим разрез \left(F,Q\right). Значит, по [[Лемма о безопасном ребре|лемме о безопасном ребре]], оно безопасно. Алгоритм построения ''MST'', добавляющий безопасные ребра, причём делающий это ровно |V|-1 раз, корректен.

== Оценка производительности ==
Производительность алгоритма Прима зависит от выбранной реализации приоритетной очереди, как и в алгоритме Дейкстры. Извлечение минимума выполняется V раз, релаксация — O(E) раз.

{| border="1" cellpadding="5" cellspacing="0" style="text-align:center" width=30%
!style="background:#f2f2f2"|Структура данных для приоритетной очереди
!style="background:#f2f2f2"|Асимптотика времени работы
|-
|style="background:#f9f9f9"|Наивная реализация
|style="background:#f9f9f9"|O(V^2+E)
|-
|style="background:#f9f9f9"|[[Двоичная куча]]
|style="background:#f9f9f9"|O(E\log{V})
|-
|style="background:#f9f9f9"|[[Фибоначчиевы кучи|Фибоначчиева куча]]
|style="background:#f9f9f9"|O(V\log{V}+E)
|}

==См. также==
* [[Алгоритм Краскала]]
* [[Алгоритм Борувки]]

== Источники информации ==
*Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн — Алгоритмы: построение и анализ, 2-е издание. Пер. с англ. — М.:Издательский дом "Вильямс", 2010. — с.653 — 656.— ISBN 978-5-8459-0857-5 (рус.)
*[http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9F%D1%80%D0%B8%D0%BC%D0%B0 Википедия — Алгоритм Прима]
*[http://en.wikipedia.org/wiki/Prim%27s_algorithm Wikipedia — Prim's algorithm]
*[http://e-maxx.ru/algo/mst_prim MAXimal :: algo :: Минимальное остовное дерево. Алгоритм Прима]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Остовные деревья ]]
[[Категория: Построение остовных деревьев]]