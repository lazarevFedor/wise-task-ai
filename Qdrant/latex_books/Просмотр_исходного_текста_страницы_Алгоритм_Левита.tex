'''Алгоритм Левита''' (англ. ''Levit's algorithm'') находит расстояние от заданной вершины s до всех остальных. Позволяет работать с ребрами отрицательного веса при отсутствии отрицательных циклов.

== Алгоритм ==

Пусть d_i {{---}} текущая длина кратчайшего пути до вершины i. Изначально, все элементы d, кроме s-го равны бесконечности; d[s] = 0.

Разделим вершины на три множества:
* M_0 {{---}} вершины, расстояние до которых уже вычислено (возможно, не окончательно),
* M_1 {{---}} вершины, расстояние до которых вычисляется. Это множество в свою очередь делится на две [[Очередь|очереди]]:
# M_1^{'} {{---}} основная очередь,
# M_1^{''} {{---}} срочная очередь;
* M_2 {{---}} вершины, расстояние до которых еще не вычислено.

Изначально все вершины, кроме s помещаются в множество M_2. Вершина s помещается в множество M_1 (в любую из очередей).

'''Шаг алгоритма:''' выбирается вершина u из M_1. Если очередь M_1^{''} не пуста, то вершина берется из нее, иначе из M_1^{'}. Для каждого ребра uv \in E возможны три случая:
* v \in M_2, то v переводится в конец очереди M_1^{'}. При этом d_v \gets d_u + w_{uv} (производится релаксация ребра uv),
* v \in M_1, то происходит релаксация ребра uv,
* v \in M_0. Если при этом d_v > d_u + w_{uv}, то происходит релаксация ребра uv и вершина v помещается в M_1^{''}; иначе ничего не делаем.
В конце шага помещаем вершину u в множество M_0.

Алгоритм заканчивает работу, когда множество M_1 становится пустым.

== Псевдокод ==

Для хранения вершин используем следующие структуры данных:
* M_0 {{---}} [[Хеш-таблица|хеш-таблица]],
* M_1 {{---}} основная и срочная [[Очередь|очереди]],
* M_2 {{---}} [[Хеш-таблица|хеш-таблица]].

 '''for''' u : u \in V
 d[u] = \infty
 d[s] = 0
 M_1^{'}.push(s)
 '''for''' u : u \neq s '''and''' u \in V
 M_2.add(u)
 '''while''' M_1^{'} \neq \varnothing '''and''' M_1^{''} \neq \varnothing
 u=(M_1^{''} = \varnothing ? M_1^{'}.pop() : M_1{''}.pop())
 '''for''' v : uv \in E
 '''if''' v \in M_2
 M_1^{'}.push(v)
 M_2.remove(v)
 d[v] = min(d[v], d[u] + w_{uv})
 '''else if''' v \in M_1
 d[v] = min(d[v], d[u] + w_{uv})
 '''else if''' v \in M_0 '''and''' d[v] > d[u] + w_{uv}
 M_1^{''}.push(v)
 M_0.remove(v)
 d[v] = d[u] + w_{uv}
 M_0.add(u)

== Доказательство ==

{{Лемма
|statement= Алгоритм отработает за конечное время
|proof= Не теряя общности, будем считать, что граф связен. Тогда алгоритм завершит работу, когда в M_0 окажутся все вершины. Так как в исходном графе нет отрицательных циклов, то для каждой вершины существует кратчайший путь. Тогда расстояние до каждой вершины может уменьшится только конечное число раз и, как следствие, вершина будет переведена из M_0 в M_1 тоже конечное число раз. С другой стороны, на каждом шаге текущая вершина гарантированно помещается в M_0. Тогда за конечное число шагов все вершины окажутся в M_0.
}}

{{Лемма
|statement= В конце работы алгоритма не найдется такое ребро uv, что его релаксация будет успешной
|proof= Предположим обратное. Тогда рассмотрим 2 случая:
# Вершина u попала в M_0 позже v. Тогда должна была произойти релаксация ребра uv и она была неуспешной. Значит, такого варианта не может быть
# Вершина u попала в M_0 раньше v. Заметим, что с момента последнего попадания u в M_0 расстояние до нее не менялось (иначе, вершина была бы извлечена из M_0). Вес ребра uv тоже не меняется. Значит, и релаксация ребра uv ничего не даст
Противоречие.
}}

Из двух предыдущих лемм напрямую следует корректность алгоритма.

== Сложность ==

При неправильной реализации алгоритма, используя вместо очередей M_1{''} и M_1{'} [[Персистентный дек|дек]] и добавляя вершины из M_0 в начало дека, алгоритм в худшем случае будет работать за экспоненциальное время, так делать не рекомендуется.

В плохих случаях алгоритм Левита работает за O(n^2m). Рассмотрим полный граф K_n с n вершинами и такими m рёбрами, идущими в [[Лексикографический порядок|лексикографическом порядке]]:
* для всех вершин 1 вес ребра (i,j) = j - i - 1, т.е. количество вершин между i и j; w_{i,i+1}=0,
* ребро (1,n) веса 0,
* для всех вершин 1 вес ребра (1,i) = w_{1,i+1} + i - 1; от 1 до i вершины расстояние равно \sum\limits_{k=i-1}^{n-2}k.
Ясно, что кратчайший путь до каждой вершины равен 0, но в плохом случае алгоритм при подсчёте вершины i будет пересчитывать все вершины до неё (кроме первой). На 1 шаге в очередь положат вершины от 2 до n, причём вершину 1 из M_0 больше не достанут. На следующем шаге добавлений не произойдёт, так как вершины больше 2 уже в очереди. На 3 шаге алгоритм улучшит расстояние до вершины 2 на 1 (что видно из веса рёбер (1,2) и (1,3), равных \sum\limits_{k=1}^{n-2}k и \sum\limits_{k=2}^{n-2}k соответственно), так что её добавят в M_1{''} и обработают на 4 шаге (релаксаций не происходит). На следующем шаге из обычной очереди достанут вершину 4, расстояние до неё, равное \sum\limits_{k=3}^{n-2}k, на 2 меньше, чем расстояние до 2 и 3 вершин. Их добавят в срочную очередь, но так как w_{24}-1=w_{34}, то после подсчёта вершины 3 вершину 2 снова добавят в M_1{''}. Затем дойдёт очередь до вершины 5, что вызовет релаксацию предыдущих вершин 2,3,4, затем прорелаксируют вершины 2,3, и после вершина 2. Аналогично будут происходить релаксации всех вершин при обработке вершины i из очереди M_0. Таким образом, вершину i будут добавлять в срочную очередь n-i раз (добавление вершин из очереди M_2 с номером больше i) + количество добавлений "старшей" вершины i+1. Количество добавлений вершины i составит 1 + \sum\limits_{k=1}^{n-i}k, а сумма всех добавлений примерно составит O(nm). При обработке каждой вершины приходится обходить n-1 ребер, что даёт оценку O(n^2m). Однако, на реальных графах алгоритм Левита работает быстрее, чем алгоритм [[Алгоритм Форда-Беллмана|Форда Беллмана]] и не многим уступает алгоритму [[Алгоритм Дейкстры|Дейкстры]].

==См. также==
* [[Алгоритм A*]]
* [[Алгоритм Дейкстры]]
* [[Алгоритм Джонсона]]
* [[Алгоритм Флойда]]
* [[Алгоритм Форда-Беллмана]]
* [[Обход в ширину]]

== Источники информации==
* [http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9B%D0%B5%D0%B2%D0%B8%D1%82%D0%B0 Википедия — Алгоритм Левита]
* [http://e-maxx.ru/algo/levit_algorithm MAXimal :: algo :: Алгоритм Левита]
* И. В. Романовский, Дискретный анализ, ISBN 5-7940-0138-0; 2008 г., 4 издание, стр. 229-231.

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Кратчайшие пути в графах]]