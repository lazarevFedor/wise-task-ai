== Алгоритм проверки наличия пути между двумя вершинами ==

{{Задача
|definition =
Дан граф G = (V, E) и две вершины s и t. Необходимо проверить, существует ли путь из вершины s в вершину t по рёбрам графа G.
}}
=== Алгоритм ===

Небольшая модификация алгоритма [[Обход в глубину, цвета вершин|обхода в глубину]]. Смысл алгоритма заключается в том, чтобы запустить обход в глубину из вершины s и проверять при каждом посещении вершины, не является ли она искомой вершиной t.
Так как в первый момент времени все пути в графе "белые", то если вершина t и была достижима из s, то по [[Лемма о белых путях|лемме о белых путях]] в какой-то момент времени мы зайдём в вершину t, чтобы её покрасить. Время работы алгоритма O(|V| + |E|).

=== Реализация ===

 // visited {{---}} массив цветов вершин 
 // t {{---}} конечная вершина 
 
 '''bool''' dfs(u, t: '''int''', visited: '''bool[]'''): 
 '''if''' u == t
 '''return''' ''true'' 
 visited[u] = ''true'' // помечаем вершину как пройденную
 '''for''' v: uv \in E // проходим по смежным с u вершинам
 '''if''' '''not''' visited[v] // проверяем, не находились ли мы ранее в выбранной вершине
 '''if''' dfs(v, t, visited)
 '''return''' ''true''
 '''return''' ''false''

== Алгоритм проверки связности графа G ==

{{Задача
|definition =
Дан [[Основные определения теории графов|неориентированный граф]] G = (V, E). Необходимо проверить, является ли он связным.
}}

=== Алгоритм ===
Снова небольшая модификация алгоритма [[Обход в глубину, цвета вершин|обхода в глубину]], в которой будем возвращать количество посещенных вершин. Запустим такой dfs() от некоторой вершины графа G, если его результат равен |V|, то мы побывали во всех вершинах графа, а следовательно он связен, иначе какие-то вершины остались непосещенными. Работает алгоритм за O(|V| + |E|).

=== Реализация ===

 // visited {{---}} массив цветов вершин 
 
 '''int''' dfs(u: '''int''', visited: '''bool[]'''): 
 '''int''' visitedVertices = 1
 visited[u] = ''true'' // помечаем вершину как пройденную
 '''for''' v: uv \in E // проходим по смежным с u вершинам
 '''if''' '''not''' visited[v] // проверяем, не находились ли мы ранее в выбранной вершине
 visitedVertices += dfs(v, visited)
 '''return''' visitedVertices

==Проверка связности вершин в режиме онлайн==
{{Задача
|definition =
Дан пустой граф G, состоящий из n вершин. Поступают запросы, каждый из которых {{---}} это пара вершин, между которыми надо добавить ребро. Необходимо в любой момент времени для двух выбранных вершин отвечать на вопрос, являются ли они связанными.
}}
===Алгоритм===
Описываемая здесь идея довольна проста и будет основываться на [[СНМ (наивные реализации)|системе непересекающихся множеств]]. 

В каждом множестве будем хранить компоненты связности графа G. Тогда ответ на запросы второго типа будет заключаться в определении множеств, в которых находятся данные вершины, т.е. две вершины являются связанными, если они лежат в одной компоненте связности. Изначально все вершины находятся в разных компонентах связности. При добавлении ребра объединяем множества, в которых находятся его концы, если те различны.

== См. также ==
*[[Обход в глубину, цвета вершин]]
*[[Использование обхода в глубину для поиска цикла]]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Обход в глубину]]