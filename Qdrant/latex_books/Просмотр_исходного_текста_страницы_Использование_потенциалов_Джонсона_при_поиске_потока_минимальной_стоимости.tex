Метод интересен прежде всего тем, что [[Сведение задачи о назначениях к задаче о потоке минимальной стоимости|задачу о назначениях]] можно свести к задаче о поиске потока минимальной стоимости, и тогда эффективность решения задачи о назначениях будет определяться именно асимптотикой работы этого алгоритма.

== Мотивация ==

Зачем нужно использовать потенциалы Джонсона?

Идея аналогична идее, использующейся в [[Алгоритм Джонсона|алгоритме Джонсона]].

При [[Поиск потока минимальной стоимости методом дополнения вдоль путей минимальной стоимости|поиске потока минимальной стоимости методом дополнения вдоль путей минимальной стоимости]] нам требуется находить минимальный по стоимости поток из истока в сток. Это реализуется с помощью алгоритмов поиска кратчайшего пути в графе. Поскольку стоимость некоторых рёбер может быть отрицательной, нам приходится использовать [[Алгоритм Форда-Беллмана|алгоритм Форда-Беллмана]]. Однако гораздо эффективней было бы применить [[Алгоритм Дейкстры|алгоритм Дейкстры]] для этой же цели, так как у него гораздо лучше асимптотика. Для этого нам надо перевзвесить рёбра графа.

{{Определение
|definition=Пусть дана транспортная сеть \,G(V,E), где V — множество вершин графа, а E — множество рёбер. Введем в каждой вершине потенциал p(v). Тогда потенциальный вес (то есть стоимость) ребра (u, v) определяется как
w_p(u, v) = w(u, v) + p(u) - p(v) 
}}
Заметим, что сумма потенциальных весов ребер вдоль любого пути отличается от суммы весов вдоль того же самого пути на разность между потенциалом первой и последней вершины.

== Использование потенциалов Джонсона ==
Возьмём значения потенциалов в вершинах равными минимальному расстоянию от истока до них, а расстояния найдём с помощью [[Алгоритм Форда-Беллмана|алгоритма Форда-Беллмана]]. Таким образом, нам его придётся запустить всего один раз, а не на каждом шаге алгоритма. Однако, после добавления потока вдоль кратчайшего увеличивающего пути в сети могут появиться новые ребра, равно как и исчезнуть старые, и будет необходимо пересчитать потенциалы, чтобы они оставались корректными, то есть p(v) - длина кратчайшего пути от истока в вершину v в новой сети. Научимся делать это, не запуская каждый раз Форда-Беллмана.

Для начала докажем, что в сети с корректными потенциалами w_p(u, v) = 0 для любого ребра (u, v), лежащего на кратчайшем пути из s в t.

Пусть s, v_1, v_2, \ldots, v_k, t - кратчайший путь из s в t, и d(u, v) - длина кратчайшего пути между вершинами u и v в исходной сети без потенциалов. Тогда w(s, v_1) + w(v_1, v_2) + \ldots + w(v_k, t) = d(s, t) и w_p(s, v_1) + w_p(v_1, v_2) + \ldots + w_p(v_k, t) = p(s) + w(s, v_1) + w(v_1, v_2) + \ldots + w(v_k, t) - p(t) = p(s) + d(s, t) - p(t) = p(s) + p(t) - p(t) = p(s) = 0. Таким образом, сумма всех потенциальных весов ребер на кратчайшем пути из s в t равна нулю. Кроме того, для любого ребра (u, v) w_p(u, v) \geq 0. Следственно, w_p(u, v) = 0 для любого ребра (u, v), лежащего на кратчайшем пути из s в t. 

Более того, потенциальный вес всех ребер, обратных ребрам из кратчайшего пути, тоже равен 0. И правда, w_p(u, v) = w(u, v) + d(s, u) - d(s, v) = 0. Умножив на -1, получаем 0 = -w(u, v) - d(s, u) + d(s, v) = w(v, u) + d(s, v) - d(s, u) = w_p(v, u)

Из доказанных выше фактов следует, что при добавлении потока вдоль кратчайшего пути в сети с корректными потенциалами не появляется ребер с отрицательным весом (однако сами потенциалы уже становятся некорректными). Но так как ребер отрицательного веса нет, то мы можем пустить алгоритм Дейкстры из s, чтобы насчитать новые потенциалы. Пусть d_1(u, v) - кратчайшее расстояние, найденное алгоритмом Дейкстры, из u в v в сети с появившимися новыми ребрами, но старыми потенциалами, а d(u, v) - кратчайшее расстояние в новой сети без потенциалов. Нетрудно заметить, что d_1(s, v) = d(s, v) - p(v), следственно, d(s, v) = d_1(s, v) + p(v). Зная настоящие расстояния от истока до каждой вершины, мы теперь можем проставить новые потенциалы. Для каждой вершины v p(v) \gets d(s, v) = d_1(s, v) + p(v).

Кроме того, мы также нашли новый кратчайший путь из истока в сток - а значит, на следующей итерации алгоритма мы можем пустить поток по нему и повторить все заново.

==Реализация==
Модифицируем псевдокод из статьи про [[Поиск потока минимальной стоимости методом дополнения вдоль путей минимальной стоимости|поиск потока минимальной стоимости методом дополнения вдоль путей минимальной стоимости]]:

 '''for''' e \in E {
 f[e] \leftarrow 0
 }
 Запустим алгоритм Форда-Беллмана, в результате для каждой вершины: p[v] — кратчайшее расстояние s \leadsto v, 
 если за длину ребра принимается его стоимость.
 '''while''' (существует путь s \leadsto t в остаточной сети G_f) {
 Восстановить P — кратчайший в смысле стоимости путь s \leadsto t, найденный на предыдущем шаге
 дополнить поток f вдоль P
 Запустить алгоритм Дейкстры из s, чтобы насчитать d_1
 '''for''' v \in V {
 p[v] \leftarrow p[v] + d_1[v]
 }
 }

==Асимптотика==
Пусть все пропускные способности целочисленны.
[[Поиск потока минимальной стоимости методом дополнения вдоль путей минимальной стоимости|Метод целиком]] работает за O(F(V, E) \cdot |f|), где F(V, E) — время одной итерации.

Время, затраченное на одну итерацию, определяется скоростью поиска кратчайшего пути.
Если для этой цели использовать [[Алгоритм Дейкстры|алгоритм Дейкстры]] с Фиббоначевыми кучами, то поиск мы осуществим за O(V \log V + E).

Не стоит так же забывать, что для расчёта потенциалов мы один раз запустили Алгоритм Форда-Беллмана.
В результате получим время работы O((V \log V + E) \cdot |f| + V E). 

Это лучше, чем O((V E) \cdot |f|), что получается при использовании [[Алгоритм Форда-Беллмана|алгоритма Форда-Беллмана]] для поиска кратчайшего пути на каждой итерации.

В применении к [[Сведение задачи о назначениях к задаче о потоке минимальной стоимости|задаче о назначениях]]: пусть у нас есть N назначений. Построим специальным образом граф. Искомый поток в нём имеет имеет мощность N. Количество вершин — O(N), рёбер — O(N^2). Итого получаем асимптотику O(N^2 \log N + 2N^3) = O(N^3).

== Литература ==
* ''Andrew V. Goldberg'' An Efficient implementation of a scaling minimum-cost flow algorithm - Journal of Algorithms, 1997

[[Категория:Алгоритмы и структуры данных]]
[[Категория: Задача о потоке минимальной стоимости]]