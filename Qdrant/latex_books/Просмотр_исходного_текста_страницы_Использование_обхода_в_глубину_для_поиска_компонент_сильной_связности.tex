==Алгоритм==
[[Файл:Dfs_strong.png|290px|thumb|Вершины 2, 4, 5 сильносвязаны.Синим цветом обозначен обод DFS по инвертированным ребрам]]
[[Отношение_связности,_компоненты_связности#Сильная связность|Компоненты сильной связности]] в графе G можно найти с помощью [[Обход_в_глубину,_цвета_вершин | поиска в глубину]] в 3 этапа:
#Построить граф H с обратными (инвертированными) рёбрами 
#Выполнить в H поиск в глубину и найти f[u] — время окончания обработки вершины u
#Выполнить поиск в глубину в G, перебирая вершины во внешнем цикле в порядке убывания f[u]
Полученные на 3-ем этапе деревья поиска в глубину будут являться компонентами сильной связности графа G.
Так как компоненты сильной связности G и H графа совпадают, то первый поиск в глубину для нахождения f[u] можно выполнить на графе G, а второй — на H.

==Доказательство корректности алгоритма==
{{Теорема
|statement=
Вершины s и t взаимно достижимы \Leftrightarrow после выполнения алгоритма они принадлежат одному дереву обхода в глубину.
|proof=
\Rightarrow

Если вершины s и t были взаимно достижимы в графе G, то на третьем этапе будет найден путь из одной вершины в другую, это означает, что по окончанию алгоритма обе вершины лежат в одном поддереве.

\Leftarrow

# Вершины s и t лежат в одном и том же дереве поиска в глубину на третьем этапе алгоритма. Значит, что они обе достижимы из корня r этого дерева. 
# Вершина r была рассмотрена вторым обходом в глубину раньше, чем s и t, значит время выхода из нее при первом обходе в глубину больше, чем время выхода из вершин s и t. Из этого мы получаем 2 случая:
##Обе эти вершины были достижимы из r в инвертированном графе. А это означает взаимную достижимость вершин s и r и взаимную достижимость вершин r и t. А складывая пути мы получаем взаимную достижимость вершин s и t.
##Хотя бы одна не достижима из r в инвертированном графе, например t. Значит и r была не достижима из t в инвертированном графе, так как время выхода r - больше . Значит между этими вершинами нет пути, но последнего быть не может, потому что t была достижима из r по пункту 1). 

Значит, из случая 2.1 и не существования случая 2.2 получаем, что вершины s и t взаимно достижимы в обоих графах.
}}

==Время работы алгоритма==
#Для того, чтобы инвертировать все ребра в графе, представленном в виде списка потребуется O(V + E) действий. Для матричного представления графа не нужно выполнять никакие действия для его инвертирования.
#Количество ребер в инвертированном равно количеству ребер в изначальном графе, поэтому поиск в глубину будет работать за O(V + E) 
#Поиск в глубину в исходном графе выполняется за O(V + E).
В итоге получаем, что время работы алгоритма O(V + E).

==Псевдокод==
Пусть G — исходный граф, H —инвертированный граф. В массиве ord будем хранить номера вершин в порядке окончания обработки поиском в глубину в графе G. В результате получаем массив component, который каждой вершине сопоставляет номер её компоненты.
 
 '''function''' dfs1(v): 
 color[v] = 1
 '''for''' (v, u) '''in''' E
 '''if''' '''not''' visited[u]
 dfs1(G[v][u])
 Добавляем вершину v в конец списка ord
 
 '''function''' dfs2(v): 
 component[v] = col
 '''for''' (v, u) '''in''' E
 '''if''' (вершина u еще не находится ни в какой компоненте) 
 dfs2(H[v][u])
 
 '''function''' main():
 считываем исходные данные, формируем массивы G и H
 '''for''' u '''in''' V 
 '''if''' '''not''' visited[u]
 dfs1(u)
 col = 1
 '''for''' (по всем вершинам u списка ord[] в обратном порядке) 
 '''if''' (вершина u не находится ни в какой компоненте)
 dfs2(u)
 col++

==Источники информации==
* Р.Седжвик. "Фундаментальные алгоритмы на С++. Алгоритмы на графах" - СПб, ДиаСофтЮП, 2002
* [http://e-maxx.ru/algo/strong_connected_components MAXimal :: algo :: Поиск компонент сильной связности, построение конденсации графа]
* [http://rain.ifmo.ru/cat/view.php/vis/graph-general/scc-2008/| Визуализация поиска компонент сильной связности]
[[Категория: Алгоритмы и структуры данных]]
[[Категория: Обход в глубину]]