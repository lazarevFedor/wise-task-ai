==Идея алгоритма==
Пусть дан [[Основные определения теории графов|неориентированный двудольный граф]] G(V, E) и требуется найти [[Теорема о максимальном паросочетании и дополняющих цепях|максимальное паросочетание]] в нём. Обозначим доли исходного графа как 
L и R. Построим граф G'(V', E') следующим образом: 

V' = V \cup \{s, t\} (т.е. добавим новый исток s и сток t);

E' = \{(s, u): u \in L\} \cup \{(u, v): u \in L, v \in R\ , (u, v) \in E\} \cup \{(v, t): v \in R\} .
{|align="center"
 |-valign="center"
 |[[Файл:GrafG.png|thumb|200px|Пример графа G.]]
 |[[Файл:GrafG2.png|thumb|200px|Соответствующий граф G'.]]
 |}
Изначально текущее паросочетание пусто. На каждом шаге алгоритма будем поддерживать следующий инвариант: в текущее найденное паросочетание входят те и только те ребра, которые направлены из R в L.
# Ищем в графе G' путь из s в t [[Обход_в_глубину,_цвета_вершин|поиском в глубину]]. 
# Если путь найден, перезаписываем текущее паросочетание. Далее инвертируем все рёбра на пути (ребро (u, v) становится ребром (v, u) ) и удаляем (s, L) и (R, t) ребра, покрывающие вершины, принадлежащие текущему паросочетанию.
# Если путь не был найден, значит текущее паросочетание является максимальным, и алгоритм завершает работу. Иначе переходим к пункту 1.

==Корректность алгоритма==

Обозначим как p' путь p из s в t без первого и последнего ребра. Пусть он
является дополняющей цепью для исходного графа G, и пусть также существование дополняющей цепи в графе G приводит к существованию пути p'. Тогда из [[Теорема о максимальном паросочетании и дополняющих цепях|теоремы]]: если мы на каком-то шаге можем найти новый путь, т.е дополняющую цепь, то мы увеличиваем текущее паросочетание. Если путь найти мы уже не можем, значит дополняющих цепей в графе нет и текущее паросочетание — искомое. Осталось доказать что сделанное предположение действительно верно.

Т. к. p' — путь в двудольном графе, начинающийся в L и заканчивающийся в R, то он нечетной длины. Вершины в нем не повторяются (т.к. это путь в дереве поиска в глубину). Рассмотрим текущее паросочетание. Согласно поддерживаемому инварианту (R,L)-ребра в паросочетании, а (L,R)-ребра {{---}} нет. В таком случае ребра пути p' можно пронумеровать так, чтобы нечетные ребра были свободными, а четные — покрытыми ребрами текущего паросочетания. Заметим, что путь может начинаться и заканчиваться только в свободной вершине, т. к. из s ведут ребра только в свободные вершины и только из свободных вершин ведут ребра в t. Итак, теперь ясно, что p' — дополняющая цепь для графа G.

Обратно, пусть существует дополняющая цепь в графе G. В одной из ориентаций она начинается в какой-то свободной вершине u \in L\ и заканчивается в свободной вершине v \in R\, далее будем рассматривать именно эту ориентацию. Ребра поочередно то не лежат, то лежат в паросочетании, значит в нашей ориентации эти ребра поочередно ориентированы то (L, R), то (R,L). Заметим что эта ориентация совпадает с ориентацией ребер на пути, а значит в нашем ориентированом графе существует путь из свободной вершины u \in L в свободную вершину v \in R. Нo каждая свободная вершина из L связана ребром с s в графе G', аналогично каждая свободная вершина из R связана ребром с t. Не сложно заметить, что, в таком случае, t достижим из s, а значит в процессе поиска в глубину будет найден некий s \rightarrow t путь p и соответствующий ему p'.

Утверждение доказано.

==Оценка производительности==

Поиск в глубину запускается от вершины s не более чем L раз, т.к. из s ведет ровно L ребер, и при каждом запуске одно из них инвертируется. Сам поиск работает за O(E), каждая инвертация и перезапись паросочетания так же занимает O(E) времени. Тогда все время алгоритма ограничено O(VE).

==Псевдокод==
* px[] {{---}} массив вершин y \in R, инцидентные x_i \in L в текущем паросочетании,
* py[] {{---}} массив вершин x \in L, инцидентные y_i \in R в текущем паросочетании,
* vis[] {{---}} массив, где помечаются посещенные вершины.
Максимальное паросочетание {{---}} такие ребра (x, y), что x \in L, y \in R, px[x] = y.

Поиск в глубину, одновременно инвертирующий ребра:
 '''bool''' dfs(x)''':'''
 '''if''' vis[x]
 '''return''' ''false''
 vis[x] = ''true''
 '''for''' (x, y) \in E
 '''if''' py[y] == -1
 py[y] = x
 px[x] = y
 '''return''' ''true''
 '''else'''
 '''if''' dfs(py[y])
 py[y] = x
 px[x] = y
 '''return''' ''true''
 '''return''' ''false''

Инициализация и внешний цикл:
 '''func''' fordFulkerson()''':'''
 fill(px, -1)
 fill(py, -1)
 isPath = ''true''
 '''while''' isPath
 isPath = ''false''
 fill(vis, ''false'')
 '''for''' x \in L
 '''if''' px[x] == -1
 '''if''' dfs(x)
 isPath = ''true''

==См. также==
* [[Теорема_о_максимальном_паросочетании_и_дополняющих_цепях|Теорема о максимальном паросочетании и дополняющих цепях]]
* [[Алгоритм_Форда-Фалкерсона,_реализация_с_помощью_поиска_в_глубину|Алгоритм Форда-Фалкерсона, реализация с помощью поиска в глубину]]

==Источники информации==
* Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн {{---}} "Алгоритмы: построение и анализ", 2-е издание, стр. 758 - 761.

[[Категория:Алгоритмы и структуры данных]]
[[Категория:Задача о паросочетании]]