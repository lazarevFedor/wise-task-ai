__TOC__

== Диаметр дерева ==
{{Определение
|id = tree
|definition =
'''Диаметр дерева''' (англ. ''diameter of a tree'') — максимальная длина (в рёбрах) кратчайшего пути в дереве между любыми двумя вершинами.
}}

Пусть дан граф G = \langle V, E \rangle . Тогда диаметром d называется \max\limits_{u, v \in V} dist(v, u), где dist — кратчайшее расстояние между вершинами.

=== Алгоритм ===
* Возьмём любую вершину v \in V и найдём расстояния до всех других вершин. d[i] = dist(v, i)

* Возьмём вершину u \in V такую, что d[u] \geqslant d[t] для любого t. Снова найдём расстояние от u до всех остальных вершин. Самое большое расстояние — диаметр дерева.
Расстояние до остальных вершин будем искать [[Обход_в_ширину|алгоритмом BFS]].

=== Реализация ===
 //граф g представлен списком смежности 
 '''int''' diameterTree('''list>''' g): 
 v = u = w = 0
 d = bfs(g, v)
 '''for''' i = 0, i d[u]
 u = i
 d = bfs(g, u)
 '''for''' i = 0, i d[w]
 w = i
 '''return''' d[w]

=== Обоснование корректности ===
Будем пользоваться свойством, что в любом дереве больше одного листа. Исключительный случай — дерево из одной вершины, но алгоритм сработает верно и в этом случае.

{{Теорема
|statement=
Искомое расстояние — расстояние между двумя листами.
|proof=
Пусть искомое расстояние — расстояние между вершинами a, b, где b не является листом. Так как b не является листом, то её степень больше единицы, следовательно, из неё существует ребро в непосещённую вершину (дважды посетить вершину b мы не можем).
}}

После запуска алгоритма получим дерево BFS.

{{Теорема
|statement=
В дереве BFS не существует ребер между вершинами из разных поддеревьев некоторого их общего предка.
|proof=
Предположим, существует ребро u, v между соседними поддеревьями:
Рассмотрим первую вершину, в которую приведет наш алгоритм, пусть это вершина u, тогда в ходе рассмотрения всех смежных вершин u мы добавим в список вершину v, тем самым исключив возможность попадания их в разные поддеревья.
}}

Мы свели задачу к нахождению вершины w, такой что сумма глубин поддеревьев максимальна.

Докажем, что одно из искомых поддеревьев содержит самый глубокий лист. 
Пусть нет, тогда, взяв расстояние от w до глубочайшего листа, мы можем улучшить ответ. 

Таким образом мы доказали, что нам нужно взять вершину u с наибольшей глубиной после первого BFS, очевидно, что ей в пару надо сопоставить вершину w, такую что dist(u, w) максимально. Вершину w можно найти запуском BFS из u. 

=== Оценка времени работы ===
Все операции кроме BFS — O(1).
BFS работает за линейное время, запускаем мы его два раза. Получаем O(|V| + |E|).

== Центр дерева ==
=== Определения ===
{{Определение
|id = tree
|definition =
'''Эксцентриситет вершины e(v)''' (англ. ''eccentricity of a vertex'') — \max\limits_{u\in V} dist(v, u), где V — множество вершин связного графа G.
}}
{{Определение
|id = tree
|definition =
'''Радиус r(G)''' (англ. ''radius'') — наименьший из эксцентриситетов вершин графа G.
}}
{{Определение
|id = tree
|definition =
'''Центральная вершина''' (англ. ''central vertex'') — вершина графа G, такая что e(v) = r(G) 
}}
{{Определение
|id = tree
|definition =
'''Центр графа G''' (англ. ''center of a graph'') — множество всех центральных вершин графа G.
}}
[[Файл:Центральные_вершины.png|300px|thumb|left|Примеры деревьев с одной и двумя центральными вершинами]]
[[Файл:Эксцентриситеты.png|400px|thumb|center|Графы, у которых показан эксцентриситет каждой вершины]]

=== Алгоритм ===
==== Наивный алгоритм ====
Найдём центр графа исходя из его определения.
* Построим матрицу A_{n \times n} (n — мощность множества V), где a_{ij} = d_{ij}, то есть матрицу кратчайших путей. Для её построения можно воспользоваться [[Алгоритм_Флойда|алгоритмом Флойда-Уоршелла]] или [[Алгоритм_Дейкстры|Дейкстры]].
* Подсчитаем максимум в каждой строчке матрицы A. Таким образом, получим массив длины n.
* Найдём наименьший элемент в этом массиве. Эта вершина и есть центр графа. В том случае, когда вершин несколько, все они являются центрами. 
Асимптотика зависит от используемого способа подсчета кратчайших путей. При Флойде это будет O(V^3), а при Дейкстре — максимум из асимптотики конкретной реализации Дейкстры и O(V^2), за которую мы находим максимумы в матрице.

==== Алгоритм для дерева за O(n) ====

{{Теорема
|statement=
Каждое дерево имеет центр, состоящий из одной вершины или из двух смежных вершин. 
|proof=
Утверждение очевидно для деревьев с одной и двумя вершинами. Покажем, что у любого другого дерева T те же центральные вершины, что и у дерева T', полученного из T удалением всех его висячих вершин. Расстояние от данной вершины дерева u до любой другой вершины v достигает наибольшего значения, когда v – висячая вершина. Таким образом, эксцентриситет каждой вершины дерева T' точно на единицу меньше эксцентриситета этой же вершины в дереве T, следовательно, центры этих деревьев совпадают. Продолжим процесс удаления и получим требуемое.
}}

Собственно, алгоритм нахождения центра описан в доказательстве теоремы.

* Пройдёмся по дереву [[Обход_в_глубину,_цвета_вершин|обходом в глубину]] и пометим все висячие вершины числом 0.
* Обрежем помеченные вершины.
* Образовавшиеся листья пометим числом 1 и тоже обрежем.
* Будем повторять, пока на текущей глубине не окажется не более двух листьев, и при этом в дереве будет тоже не более двух листьев. 

Оставшиеся листья являются центром дерева.

Для того, чтобы алгоритм работал за O(n), нужно обрабатывать листья по одному, поддерживая в [[Очередь|очереди]] два последовательных по глубине слоя.

== См. также ==
*[[Дерево,_эквивалентные_определения|Дерево, эквивалентные определения]]
*[[Дополнительный,_самодополнительный_граф|Дополнительный, самодополнительный граф]]

== Источники информации ==
* [[wikipedia:Distance_(graph_theory)|Wikipedia {{---}} Distance (graph theory)]]
* ''Ф. Харари'': Теория графов
* [http://rain.ifmo.ru/cat/data/theory/graph-location/centers-2006/article.pdf ''А. Клебанов'': Центры графов(нерабочая ссылка)]

[[Категория: Дискретная математика и алгоритмы]]
[[Категория: Основные определения теории графов]]