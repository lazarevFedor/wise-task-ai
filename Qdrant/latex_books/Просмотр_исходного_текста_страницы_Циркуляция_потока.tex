{{Определение
|definition=
Поток нулевой величины в [[Определение сети, потока|сети]] \(G(V, E)\) называется '''циркуляцией''' (англ. ''circulation problem''). Каждое ребро \(e_i\) имеет \(l_i\) и \(c_i\) {{---}} минимальная и максимальная пропускная способности соответственно. Необходимо выяснить, существует ли в этой сети циркуляция, удовлетворяющая пропускным способностям рёбер. 
}}
[[Файл:Циркул2.png|frame|справа|Рисунок 1. Пример графа и циркуляции в нем (поток/пропуск.способность)]]

Иначе говоря, [[Определение сети, потока#Определение потока|закон сохранения потока]] \sum\limits_v f(u,v)=0 должен выполняться для '''всех''' вершин графа, а значит нет нужды в истоке и стоке. Когда все \(l_i\) равны \(0\) , достаточно пустить поток нулевой величины из каждой вершины, что и будет ответом. Поэтому далее в графе будут существовать рёбра с положительной нижней пропускной способностью.

==Решение==
Для решения этой задачи заменим исходную сеть \(G\) на \(G'\) следующим образом. Сначала добавим в граф вершины \(s\) {{---}} исток и \(t\) {{---}} сток. Для каждого ребра \(e_i = v_{from} \xrightarrow{l_i, c_i} v_{to}\) добавим рёбра \(s \xrightarrow{0, l_i} v_{to}\) и \(u_{from} \xrightarrow{0, l_i} t\) , а также сделаем в ребре \(e_i\) изменения: \(c_i = c_i - l_i, l_i = 0\) (см. рисунок 2).

[[Файл:Циркуляция.png|frame|center|Рисунок 2. Слева - изначальный граф. Для каждого ребра заданы его нижняя и верхняя пропускные способности. Справа - граф после преобразований рёбер.]]

Каждое ребро изначального графа заменяется на три новых. Если по ребру \(e_i = (v_{from}, v_{to})\) в исходной сети протекает поток \(l_i \leqslant f_i \leqslant c_i\) , то в новой сети по ребру \((s, v_{to})\) должен течь поток, равный \(l_i\) , то есть его пропускной способности. Поток, который вытекает из \(v_{from}\) по ребру в \(G\) , заменяется на поток, который протекает по рёбрам \((v_{from}, v_{to})\) и \((v_{from}, t)\) (поскольку сумма их пропускных способностей в полученном графе равна \(c_i\) ). Аналогично, для вершины \(v_{to}\) суммарный входящий поток не изменился. Таким образом, любой допустимый поток по любому ребру в изначальном графе можно распределить между тремя рёбрами в полученном графе. Заметим, что в сети \(G'\) все \(l_i = 0\) , то есть мы имеем обыкновенную сеть.

Требовалось найти циркуляцию в исходной сети, а значит проверить существование потока, для которого выполнено равенство \sum\limits_v f(u,v) = 0 для всех вершин графа. Это равносильно существованию потока между вершинами \(s\) и \(t\) в сети \(G'\) , который полностью насытит рёбра, исходящие из истока. Действительно, этот поток в исходном графе насытит \(i\) -ое ребро как минимум на \(l_i\) , что и является необходимым требованием. Если этот поток существует, то будет выполнено:
* \(\sum\limits_v f(u,v)=0,\) где \(u \in V'-\{s,t\}, v \in V'\) , то есть для всех исходных вершин;
* В \(G': f_i \leqslant c_i - l_i \Rightarrow 0 \leqslant f_i \leqslant c_i - l_i \Rightarrow l_i \leqslant f_i + l_i \leqslant c_i\) , что удовлетворяет всем ограничениям.
Значит, этот поток и есть циркуляция. 

Запустим в новой сети один из алгоритмов поиска максимального потока. Если он не смог полностью насытить все рёбра из истока, то и никакой другой по величине поток этого сделать не сможет, значит, циркуляции нет. Для получения величин потоков вдоль каждого ребра в изначальной сети достаточно прибавить к потокам вдоль рёбер в сети \(G'\) соответствующие значения минимальной пропускной способности.

==Псевдокод==
Конструктор ребра принимает следующие аргументы:
* \mathtt{from} {{---}} вершина начала ребра
* \mathtt{to} {{---}} вершина конца ребра
* \mathtt{minCap} {{---}} минимальная пропускная способность ребра
* \mathtt{maxCap} {{---}} максимальная пропускная способность ребра
 '''function''' circulation(V,E):
 G'= (V \cup s \cup t, \varnothing) // создаём новый граф с исходными вершинами и добавлением s и t {{---}} исток и сток
 '''for''' e : e\in E
 g = Edge(s, e.to, 0, e.minCap)
 h = Edge(e.from, e.to, 0, e.maxCap - e.minCap)
 k = Edge(e.from, t, 0, e.minCap)
 G'=G' \cup (\varnothing, g \cup h \cup k)
 maxFlow = getMaxFlow(G') // наибольший поток в графе G'
 '''for''' e : e\in E' '''and''' e.from =s
 '''if''' f(e) .maxCap // если для текущего ребра flow 
 '''return''' false
 '''return''' true

==Источники информации==
* [http://dl.dropbox.com/u/39566886/Graph-Theory-Algorithms-M-Ashraf-Iqbal.pdf M. Ashraf Iqbal {{---}}'''Graph Theory and Algorithms''']
* [http://e-maxx.ru/algo/flow_with_limits MAXimal :: algo :: flow with limits]
* [https://en.wikipedia.org/wiki/Circulation_problem Wikipedia — Circulation problem]

[[Категория:Алгоритмы и структуры данных]]
[[Категория:Задача о максимальном потоке]]