{{Задача
|definition=Дан [[Отношение связности, компоненты связности|связный]] [[Основные определения теории графов|неориентированный граф]] G . Найти все [[Точка сочленения, эквивалентные определения|точки сочленения]] в G за время O(|V| + |E|).
}}

== Алгоритм ==

=== Описание алгоритма ===
Запустим [[Обход в глубину, цвета вершин|обход в глубину]] из произвольной вершины графа; обозначим её через root. Заметим следующий факт:

* Пусть мы находимся в обходе в глубину, просматривая сейчас все рёбра из вершины v. Тогда, если текущее ребро (v,to) таково, что из вершины to и из любого её потомка в дереве обхода в глубину нет обратного ребра в вершину v или какого-либо её предка, то эта вершина является точкой сочленения. В противном случае она ей не является. (В самом деле, мы этим условием проверяем, нет ли другого пути из v в to, кроме как спуск по ребру (v,to) дерева обхода в глубину.)

Теперь осталось научиться проверять этот факт для каждой вершины эффективно. Для этого воспользуемся "временами входа в вершину", вычисляемыми алгоритмом поиска в глубину.

[[Файл:Joint_point_2_rsz.png‎|280px|thumb|left| Красным цветом обозначены точки сочлененияСиним — ребра по которым идет DFS]]
Пусть tin[u] — время входа поиска в глубину в вершину u. Через up[u] обозначим минимум из времени захода в саму вершину tin[u], времен захода в каждую из вершин p, являющуюся концом некоторого обратного ребра (u,p), а также из всех значений up[v] для каждой вершины v, являющейся непосредственным сыном u в дереве поиска.

Тогда из вершины u или её потомка есть обратное ребро в её предка \Leftrightarrow \exists такой сын v, что up[v] &lt; tin[u].

Таким образом, если для текущей вершины u \ne root существует непосредственный сын v: up[v] \geqslant tin[u], то вершина u является точкой сочленения, в противном случае она точкой сочленения не является.

=== Псевдокод ===
 
 '''function''' findCutPoints(G[n]: '''Graph'''): // функция принимает граф G с количеством вершин n и выполняет поиск точек сочленения во всем графе 
 visited = array[n, ''false'']
 
 '''function''' dfs(v: '''int''', p: '''int'''):
 time = time + 1
 up[v] = tin[v] = time 
 visited[v] = ''true''
 count = 0 
 '''for''' u: (v, u) '''in''' G 
 '''if''' u == p
 '''continue'''
 '''if''' visited[u]
 up[v] = min(up[v], tin[u])
 '''else'''
 dfs(u, v) 
 count = count + 1
 up[v] = min(up[v], up[u])
 '''if''' p != -1 '''and''' up[u] >= tin[v]
 v — cutpoint 
 '''if''' p == -1 '''and''' count >= 2
 v — cutpoint 
 
 '''for''' i = 1 '''to''' n 
 '''if''' '''not''' visited[i] 
 dfs(i, -1)

=== Доказательство корректности ===
{{Теорема
|statement=
Пусть T — дерево [[Обход в глубину, цвета вершин|обхода в глубину]], root — корень T. 
* Вершина u \ne root — точка сочленения \Leftrightarrow \exists v \in T — сын u : из v или любого потомка вершины v нет обратного ребра в предка вершины u. 
* root — точка сочленения \Leftrightarrow root имеет хотя бы двух сыновей в дереве поиска в глубину.
|proof=
[[Файл:Joint_point_1.png|48px |thumb|‎ | Рисунок к \Leftarrow]]
\Leftarrow

#Удалим u из G. Докажем, что не существует пути из v в любого предка вершины u. Пусть это не так. Тогда \exists x \in T — предок u : \exists путь из v в x в G \backslash u. Пусть w — предпоследняя вершина на этом пути, w — потомок v. (w, x) — не ребро дерева T(в силу единственности пути в дереве) \Rightarrow (w, x) — обратное ребро, что противоречит условию.
#Пусть у root хотя бы два сына. Тогда при удалении root не существует пути между его поддеревьями, так как не существует перекрестных ребер \Rightarrow root — точка сочленения.

\Rightarrow
#Докажем что из отрицания второго утверждения следует отрицание первого. Обозначим через G' граф, состоящий из вершин, не являющихся потомками u. Удалим вершину u. Очевидно, что граф G' и все поддеревья вершины u останутся связными, кроме того из каждого поддерева есть ребро в G' \Rightarrow G \backslash u — связный \Rightarrow u — не точка сочленения.
#Пусть root — точка сочленения и у него есть только один сын. Тогда при удалении root остается дерево с корнем в его сыне, содержащее все остальные вершины графа, то есть оставшийся граф связен — противоречие с тем, что root — точка сочленения.
}}

=== Асимптотика ===
Оценим время работы алгоритма. Процедура \mathrm{dfs} вызывается от каждой вершины не более одного раза, а внутри процедуры рассматриваются все такие [[Основные определения теории графов|ребра]] \{e\ |\ \mathrm{begin(e)} = v\}. Всего таких ребер для всех вершин в графе O(E), следовательно, время работы алгоритма оценивается как O(V+E). Такое же, как у [[Обход в глубину, цвета вершин|обхода в глубину]].

== См. также ==
* [[Использование обхода в глубину для поиска мостов]]
* [[Обход в глубину, цвета вершин]]
* [[Обход в ширину]]

== Источники информации==
* Асанов М., Баранский В., Расин В. — Дискретная математика: Графы, матроиды, алгоритмы — Лань, 2010. — 368 с. — ISBN 978-5-8114-1068-2
* [http://e-maxx.ru/algo/cutpoints MAXimal :: algo :: Поиск точек сочленения]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Обход в глубину]]