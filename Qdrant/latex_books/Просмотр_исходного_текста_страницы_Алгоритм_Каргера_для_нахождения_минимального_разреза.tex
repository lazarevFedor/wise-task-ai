'''Алгоритм Каргера''' (англ. ''Karger's algorithm'') {{---}} рандомизированный алгоритм для нахождения минимального разреза в связном графе. Он был разработан Дэвидом Каргером (англ. ''David Karger'') в 1993 году.

== Основные определения ==
Пусть G {{---}} неориентированный [[Основные_определения_теории_графов#def1 | мультиграф]] с множеством вершин V и множеством ребер E, и |V| = n, |E| = m.
{{Определение
|definition=
'''Стягиванием''' (англ. ''contraction'') ребра uv назовем следующую последовательность действий:
# Добавляем новую вершину w. 
# Для всех ребер xu и xv (где x \in V, x \neq v, x \neq u) добавляем новые ребра xw. При этом, если получаются кратные ребра {{---}} оставляем их.
# Удаляем вершины u и v и все инцидентные им ребра.
}}

{{Определение
|definition=
'''Мультивершиной''' (англ. ''supervertex'') называется вершина, полученная из двух вершин стягиванием ребра между ними, каждая из которых, в свою очередь, может быть также мультивершиной.
}}

{{Определение
|definition=
'''Стянутым графом''' (англ. ''contracted graph'') называется граф, состоящий из двух мультивершин или одной мультивершины и одной обычной вершины (которую, чтобы избежать оговорок в дальнейшем, также будем называть мультивершиной), полученный из исходного графа последовательным стягиванием произвольных ребер.
}}

{{Определение
|definition=
'''Разрезом''' (англ. ''cut'') \langle A, B \rangle называется разбиение множества V на два множества A и B, удовлетворяющее следующим условиям:
* A, B \subset V,
* A, B \neq \emptyset,
* A \cap B = \emptyset,
* A \cup B = V.
}}
Такой разрез часто называют также глобальным разрезом, чтобы отличать его от [[Разрез, лемма о потоке через разрез#Определение разреза|(s,t)-разреза]].

{{Определение
|definition=
'''Вес разреза''' \langle A, B \rangle обозначается w(A, B) и вычисляется по формуле:
* для взвешенного графа - w(A, B) = \sum\limits_{uv \in E, u \in A, v \in B} w(uv);
* для невзвешенного графа - w(A, B) = |\{uv: u \in A, v \in B\}|.
}}

Задача поиска разреза минимальной веса (англ. ''min-cut problem'') заключается в поиске разреза минимального веса среди всех возможных разрезов исходного графа. Эту задачу можно решить с помощью любого из алгоритмов поиска максимального потока, зафиксировав произвольную вершину s в качестве истока и запуская его O(n) раз для всех возможных стоков. Если использовать быстрый алгоритм поиска максимального потока, работающий за O(mn), то время работы такого алгоритма поиска минимального разреза будет O(n^2m). Ниже описан более простой в реализации и сравнимый по скорости алгоритм Каргера. При некоторых оптимизациях, этот алгоритм работает значительно быстрее, чем использование алгоритмов поиска максимального потока.

== Алгоритм ==
Пусть нам дан граф G = \{V, E\}.

 '''int''' minCut(G):
 answer = \infty
 '''for''' i = 1 '''to''' count
 curCut = getCut(G)
 '''if''' curCut 
Так как алгоритм вероятностный и функция \mathrm{getCut} возвращает вес случайного потока, а не минимального, то для того, чтобы наверняка найти вес минимального, необходим вызвать эту функцию count раз. Какое конкретное значение count выбрать будет описано ниже.
Реализация функции \mathrm{getCut} {{---}} это и есть основа алгоритма. Будем действовать следующим образом: пока вершин больше двух, будем выбирать случайное ребро и стягивать его. Когда в графе останется две вершины, то количество ребер между этими вершинами будет равно весу некоторого разреза исходного графа. 

 '''int''' getCut(graph):
 G = graph 
 vertexCount = количество вершин в G
 '''while''' vertexCount > 2
 edge = случайное ребро из G
 contract(edge) //стягиваем ребро edge
 vertexCount--
 edgeCount = количество ребер в G
 '''return''' edgeCount

== Корректность алгоритма ==
Докажем корректность алгоритма. Для удобства доказательства и оценок вероятностей, будем считать, что мы ищем не просто вес минимального разреза, а величину конкретного минимального разреза. То есть зафиксируем какой-то один из минимальных разрезов, и если функция \mathrm{getCut} вернет правильный вес, но посчитает его на другом минимальном разрезе, то будем считать, что ответ получен неверный. Это условие не ухудшает оценки вероятностей и время работы алгоритма.
{{Лемма
|about = 1
|id = Лемма1
|statement = Пусть w {{---}} некоторая мультивершина, u и v - какие-то две из вершин, которые были стянуты в вершину w. Тогда существует такой путь p в исходном графе G между вершинами u и v, что ко всем ребрам этого пути была применена операция стягивания. 

|proof =
Рассмотрим подграф G' исходного графа G в который входят все ребра, которые были стянуты в вершину w. Очевидно, что G' связен, а значит в нем существует путь между его любыми двумя вершинами. Следовательно, существует путь между u и v, состоящий из стянутых ребер. Лемма доказана.
}}

{{Лемма
|about = 2
|id = Лемма2
|statement = Если стянуть некоторое ребро e = uv в графе G, то вес минимального разреза в графе G' = G\setminus e будет не меньше чем вес минимального разреза в исходном графе G.

|proof =
Составим биекцию между ребрами графов G и G', не рассматривая ребра между вершинами u и v в графе G. Очевидно, что это возможно, исходя из следующих соображений. Все ребра в G, не инцидентные вершинам u и v, остались без изменений, а всем ребрам, инцидентным этим вершинам, по определению стягивания можно сопоставить новое ребро в G'. Пусть \langle A', B' \rangle {{---}} минимальный разрез в графе G', и, не уменьшая общности, w \in A'. Рассмотрим разрез \langle A, B' \rangle в графе G. Исходя из биекции между ребрами и тем, что все ребра вида uv не пересекают разрез (так как u \in A, v \in A), то w(A', B') = w(A, B'). Тогда если разрез \langle A, B' \rangle в графе G {{---}} минимален, вес минимального разреза в G' совпадает с весом минимального размера в G. Если в G существует разрез меньшего веса, то вес минимального разреза в G' больше чем в G. Лемма доказана.
}}

{{Лемма
|about = 3
|id = Лемма3
|statement = Пусть c {{---}} вес минимального потока в графе G. Тогда m \geqslant nc/2. 

|proof =
Заметим, что, чтобы выполнялось условие, степень каждой вершины должна быть не менее, чем c. Действительно, пусть \deg(v) для некоторой вершины v \in V. Тогда w(v, G \setminus v) = \deg(v) , что противоречит условию. Далее, по [[Лемма_о_рукопожатиях|лемме о рукопожатиях]] имеем, что m \geqslant nc/2. Лемма доказана.
}}

{{Лемма
|about = 4
|id = Лемма4
|statement = Функция \mathrm{getCut} после своего выполнения получит стянутый граф G' соответствующий конкретному разрезу \langle A, B \rangle исходного графа G тогда и только тогда, когда ни одно ребро, принадлежащее разрезу \langle A, B \rangle, не будет стянуто.

|proof =
Необходимость. От противного. Если некоторое ребро uv, принадлежащее разрезу \langle A, B \rangle в G будет стянуто, то обе вершины u и v будут принадлежать одной мультивершине, а значит G' не соответствует разрезу \langle A, B \rangle. Противоречие.

Достаточность. Пусть ни одно ребро, принадлежащее разрезу \langle A, B \rangle не было стянуто. Рассмотрим произвольную пару вершин u \in A и v \in B в графе G. Если алгоритм стянул u и v в одну мультивершину в G', тогда по [[#лемма1|лемме 1]] существует путь p между вершинами u и v, и все ребра этого пути были стянуты. Но p пересекает разрез \langle A, B \rangle, что противоречит предположению, что ни одно ребро не было стянуто. Значит, вершины из любой пары u \in A, и v \in B были стянуты в разные мультивершины. А так, как стянутый граф состоит только из двух мультивершин, значит одна из них была получена стягиванием всех вершин из A, а другая {{---}} из B. Лемма доказана.
}}

{{Теорема
|statement =
Для вероятности p того, что функция \mathrm{getCut} после своего выполнения получит стянутый граф G' соответствующий конкретному разрезу \langle A, B \rangle исходного графа G верна следующая оценка снизу {{---}} p(\langle A, B \rangle) \geqslant \frac{2}{n^2}.
|proof =
По [[#Лемма4|лемме 4]] искомый стянутый граф будет получен тогда и только тогда, когда ни одно из ребер разреза не будет стянуто. Так как на каждой итерации алгоритма мы случайно выбираем ребро для стягивания, то можно оценить вероятность того, что ни одно из ребер разреза не будет стянуто. Каждое стягивание уменьшает количество ребер на 1. Таким образом после i-ой итерации алгоритма количество вершин в текущем графе будет равно n - i + 1. Рассчитаем вероятность того, что на i-ой итерации будет стянуто ребро из разреза \langle A, B \rangle. Пусть w = w(A, B). По [[#Лемма2|лемме 2]] величина минимального потока в текущем графе будет не меньше, чем w, и в нем будет не менее \frac{w(n-i+1)}{2} вершин по [[#Лемма3|лемме 3]]. Тогда вероятность того, что будет стянуто ребро из разреза \langle A, B \rangle, при условии, что до этого не было стянуто ни одно из ребер разреза, будет не более 

\frac{2\cdot w(A,B)}{w\cdot (n-i+1)}=\frac{2}{n-i+1}.

Обозначим за \xi_i событие, что на i-ой итерации случайным образом будет выбрано ребро из разреза \langle A, B \rangle. Тогда мы только что установили, что

p(\xi_i | \overline{\xi_1} \wedge \ldots \wedge \overline{\xi_{i-1}}) \leqslant \frac{2}{n-i+1}.

p(\overline{\xi_i} | \overline{\xi_1} \wedge \ldots \wedge \overline{\xi_{i-1}}) = 1 - p(\xi_i | \overline{\xi_1} \wedge \ldots \wedge \overline{\xi_{i-1}}) \geqslant 1 - \frac{2}{n-i+1} = \frac{n-i-1}{n-i+1}.

Тогда вероятность того, что во время работы функции не будет стянуто ни одно ребро оценивается следующим образом:

p(\overline{\xi_1} \wedge \ldots \wedge \overline{\xi_{n-2}}) = \prod\limits_{i=1}^{n-2} p(\overline{\xi_i} | \overline{\xi_1} \wedge \ldots \wedge \overline{\xi_{i-1}}) \geqslant 

\geqslant \prod\limits_{i=1}^{n-2} \frac{n-i-1}{n-i+1} = \frac{n - 2}{n} \cdot \frac{n-3}{n-1} \cdot \frac{n-4}{n-2} \cdot \ldots \cdot \frac{2}{4} \cdot \frac{1}{3} = \frac{2}{n(n-1)} \geqslant \frac{2}{n^2}.

Теорема доказана.
}}

Таким образом, мы видим, что вероятность получить правильный ответ после единичного запуска функции \mathrm{getCut} очень мала. Однако, вызвав эту функцию count раз мы увеличим эту вероятность. Рассчитаем значение count такое, чтобы вероятность успеха была близка к 1.

Для этого воспользуемся следующим неравенством:

 e^x \geqslant 1 + x для любого вещественного x.

Вероятность того, что мы не получим правильный ответ после count независимых запусков равна

(1-\frac{2}{n^2})^c.

Пусть count = n^2\ln(n). Тогда в силу указанного выше неравенства:

(1-\frac{2}{n^2})^{count} \leqslant e^{count \cdot (-\frac{2}{n^2})} = e^{-2 \ln(n)} = \frac{1}{n^2}.

То есть, если вызвать функцию \mathrm{getCut} n^2\ln(n) раз, и после каждой итерации запоминать минимум, то вероятность того, что найденный ответ будет неверен \leqslant \frac{1}{n^2}. Даже при небольших значениях n алгоритм практически гарантированно выдает правильный ответ.

== Оценка времени работы алгоритма ==
Время работы функции \mathrm{getCut} {{---}} O(n^2). Функция работает O(n^2\log(n)) раз. Итоговое время работы {{---}} O(n^4 \log(n)).

== Оптимизация алгоритма ==
Каргер совместно со Штейном (англ. ''Stein'') придумали оптимизацию алгоритма Каргера, значительно ускоряющую время его работы. Новый алгоритм называется в честь обоих создателей {{---}} алгоритм Каргера-Штейна (англ. ''Karger-Stein algorithm''). Его суть заключается в следуюшем. Заметим, что вероятность стягивания вершины, принадлежащей минимальному разрезу, в начале выполнения функции \mathrm{getCut} довольно мала, в то время, как вероятность стянуть ребро, которое не следует стягивать, ближе к концу работы функции существенно возрастает. Тогда будем использовать следующую рекурсивную версию алгоритма:
# Запускаем функцию \mathrm{getCut} и стягиваем ребра до тех пор, пока не останется \frac{n}{\sqrt{2}} вершин.
# Запускаем независимо эту же функцию для получившегося графа дважды и возвращаем минимальный из ответов.
Такая модификация алгоритма выдает правильный ответ с точностью, не менее \frac{1}{\log(n)}. Время работы функции \mathrm{getCut} вычисляется рекурсивной функцией:

T(n) = O(n^2) + 2 * T(n/\sqrt{2}) = O(n^2\log(n)).

Это медленнее, чем оригинальный алгоритм, однако вероятность нахождения разреза минимального веса экспоненциально выше. Достаточно запустить алгоритм c\log^2(n) раз, где c - некоторая константа. Действительно, рассчитаем вероятность неправильного ответа также, как раньше:

(1-\frac{1}{log(n)})^{c\log^2(n)} \leqslant e^{c\log^2(n) \cdot -\frac{1}{log(n)}} = \frac{1}{n^c}.

Итоговое время работы {{---}} O(n^2\log(n)) \cdot c\log^2(n) = O(n^2\log^3(n)).

== Источники ==
* Jon Kleinberg, Éva Tardos. Algorithm Design, section 13.2. Min-Cut and Randomization.
* [http://en.wikipedia.org/wiki/Karger's_algorithm Karger's algorithm — Wikipedia]
* [http://nickhar.wordpress.com/2012/02/06/lecture-10-minimum-cuts-by-the-contraction-algorithm/ Lecture notes for CPSC 536N "Randomized Algorithms"]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Задача о максимальном потоке]]