{{Задача
|definition=Для заданного взвешенного [[Основные определения: граф, ребро, вершина, степень, петля, путь, цикл|графа]] G = (V, E) найти кратчайшие пути из заданной вершины s до всех остальных вершин.
В случае, когда в графе G содержатся [[Основные определения: граф, ребро, вершина, степень, петля, путь, цикл|циклы]] с отрицательным суммарным весом, достижимые из s, сообщить, что кратчайших путей не существует.
}}

==Введение==
Количество путей длины k рёбер можно найти с помощью метода [[Динамическое_программирование|динамического программирования]]. 
Пусть d[k][u] {{---}} количество путей длины k рёбер, заканчивающихся в вершине u. Тогда d[k][u] = \sum\limits_{v : vu \; \in E} d[k-1][v] .

Аналогично посчитаем пути кратчайшей длины. Пусть s {{---}} стартовая вершина. Тогда d[k][u] = \min\limits_{v : vu \; \in E}(d[k-1][v] \: + \: \omega(u, v)), при этом d[0][s] = 0, а d[0][u] = +\infty 
{{Лемма
|statement=Если существует кратчайший путь от s до t, то \rho(s, \, t) \: = \: \min\limits_{k = 0..n-1} d[k][t]
|proof=Пусть кратчайший путь состоит из k ребер, тогда корректность формулы следует из динамики, приведенной ниже.
}}

==Псевдокод==
Используя приведенные формулы, алгоритм можно реализовать методом динамического программирования.

 '''for''' k = 0 '''to''' |V| - 2 // вершины нумеруются с единицы
 '''for''' v \in V
 '''for''' (u, v) \in E 
 d[k + 1][v] = min(d[k + 1][v], d[k][u] + \omega(u, v)) // \omega(u, v) {{---}} вес ребра uv

Также релаксацию можно свести к одномерному случаю, если не хранить длину пути в рёбрах. Одномерный массив будем обозначать d', тогда d'[u] = \min(d'[u], \; d'[v] + \omega(vu))

==Корректность==

{{Лемма
|statement=Пусть G = (V, E) — взвешенный ориентированный граф, s — стартовая вершина.
Тогда после завершения k итераций цикла \mathrm{for} выполняется неравенство \rho(s, u) \leqslant d'[u] \leqslant \min\limits_{i = 0..k} d[i][u].
|proof=Воспользуемся индукцией по k:

'''База индукции''' 
:При k = 0 выполнено: \rho(s, u) \leqslant +\infty \leqslant +\infty 

'''Индукционный переход'''
:Сначала докажем, что \rho(s, u) \leqslant d'[u].
:Пусть после k - 1 итерации выполняется \rho(s, u) \leqslant d'[u] \leqslant \min\limits_{i=0..k-1} d[i][u] для всех u.
:Тогда после k итераций \rho(s, v) = \min\limits_{u \in V} (\rho(s, u) + \omega(uv)) \leqslant \min\limits_{u \in V} (d'[u] + \omega(uv)) = d'[v].

:Переходим ко второму неравенству.
:Теперь возможно два случая:
:#\min\limits_{i = 0..k+1} d[i][u] = d[k+1][u]
:#\min\limits_{i = 0..k+1} d[i][u] = d[j][u] =\min\limits_{i = 0..j} \; d[i][u]

:Рассмотрим 1 случай:
::\min\limits_{i = 0..k+1} d[i][u] = d[k+1][u]
::d'[u] \leqslant d'[v] + \omega(vu) \leqslant d[k][v] + \omega(vu) = d[k+1][u]
:2 случай расписывается аналогично.

Таким образом переход выполнен и \rho(s, u) \leqslant d'[u] \leqslant \min\limits_{i = 0..k} d[i][u] выполняется.
}}

==Реализация алгоритма и ее корректность==
 '''bool''' fordBellman(s)''':'''
 '''for''' v \in V
 d[v] = \mathcal {1}
 d[s] = 0
 '''for''' i = 0 '''to''' |V| - 1 
 '''for''' (u, v) \in E 
 '''if''' d[v] > d[u] + \omega(u, v) // \omega(u, v) {{---}} вес ребра uv
 d[v] = d[u] + \omega(u, v)
 '''for''' (u, v) \in E 
 '''if''' d[v] > d[u] + \omega(u, v)
 '''return''' ''false''
 '''return''' ''true''

В этом алгоритме используется релаксация, в результате которой d[v] уменьшается до тех пор, пока не станет равным \delta(s, v).
d[v] {{---}} оценка веса кратчайшего пути из вершины s в каждую вершину v \in V.
\delta(s, v) {{---}} фактический вес кратчайшего пути из s в вершину v.

{{Лемма
|statement=Пусть G = (V, E) {{---}} взвешенный ориентированный граф, s {{---}} стартовая вершина. Тогда после завершения |V| - 1 итераций цикла для всех вершин, достижимых из s, выполняется равенство d[v] = \delta (s, v) .
|proof=Рассмотрим произвольную вершину v, достижимую из s.
Пусть p = \langle v_0,..., v_{k} \rangle , где v_0 = s, v_{k} = v {{---}} кратчайший ациклический путь из s в v . Путь p содержит не более |V| - 1 ребер. Поэтому k \leqslant |V| - 1.

Докажем следующее утверждение: 
:После n : (n \leqslant k) итераций первого цикла алгоритма, d[v_n] = \delta(s, v_n) 
Воспользуемся индукцией по n:

'''База индукции'''
:Перед первой итерацией утверждение очевидно выполнено: d[v_0] = d[s] = \delta(s, s) = 0
'''Индукционный переход'''
:Пусть после n : (n итераций, верно что d[v_n] = \delta(s, v_n). Так как (v_n, v_{n + 1}) принадлежит кратчайшему пути от s до v, то \delta(s, v_{n+1}) = \delta(s, v_n) + \omega(v_n, v_{n + 1}). Во время l + 1 итерации релаксируется ребро (v_n,v_{n+1}), следовательно по завершению итерации будет выполнено
::d[v_{n+1}] \leqslant d[v_n] + \omega(v_n, v_{n+1}) = \delta(s, v_n) + \omega(v_n, v_{n+1}) = \delta(s, v_{n+1}).
:Ясно, что d[v_{n+1}] \geqslant \delta(s, v_{n+1}) , поэтому верно что после l + 1 итерации d[v_{n+1}] = \delta(s, v_{n + 1}). 
:Индукционный переход доказан.

Итак, выполнены равенства d[v] = d[v_{k}] = \delta (s, v_{k}) = \delta (s, v).
}}

{{Теорема
|statement=Пусть G = (V, E) {{---}} взвешенный ориентированный граф, s {{---}} стартовая вершина. Если граф G не содержит отрицательных циклов, достижимых из вершины s , то алгоритм возвращает true и для всех v \in V \ d[v] = \delta (s, v). Если граф G содержит отрицательные циклы, достижимые из вершины s , то алгоритм возвращает false .
|proof=Пусть граф G не содержит отрицательных циклов, достижимых из вершины s .

Тогда если вершина v достижима из s , то по лемме d[v] = \delta (s, v). Если вершина v не достижима из s , то d[v] = \delta (s, v) = \mathcal {1} из несуществования пути. 

Теперь докажем, что алгоритм вернет значение true .

После выполнения алгоритма верно, что для всех (u, v) \in E, \ d[v] = \delta (s, v) \leqslant \delta (s, u) + \omega (u,v) = d[u] + \omega (u,v), значит ни одна из проверок не вернет значения false .

Пусть граф G содержит отрицательный цикл c = {v_0,...,v_{k}} , где v_0 = v_{k} , достижимый из вершины s . Тогда \sum\limits_{i=1}^{k} {\omega (v_{i-1}, v_{i})} .

Предположим, что алгоритм возвращает true , тогда для i = 1,...,k выполняется d[v_{i}] \leqslant d[v_{i-1}] + \omega (v_{i-1}, v_{i}) .

Просуммируем эти неравенства по всему циклу: \sum\limits_{i=1}^{k} {d[v_{i}]} \leqslant \sum\limits_{i=1}^{k} {d[v_{i-1}]} + \sum\limits_{i=1}^{k} {\omega (v_{i-1}, v_{i})} .

Из того, что v_0 = v_{k} следует, что \sum\limits^{k}_{i=1} {d[v_{i}]} = \sum \limits_{i=1}^{k} {d[v_{i - 1}]} .

Получили, что \sum \limits_{i=1}^{k} {\omega (v_{i-1}, v_{i})} \geqslant 0 , что противоречит отрицательности цикла c .
}}

==Сложность==
Инициализация занимает \Theta (V) времени, каждый из |V| - 1 проходов требует \Theta (E) времени, обход по всем ребрам для проверки наличия отрицательного цикла занимает O(E) времени. Значит алгоритм Беллмана-Форда работает за O(V E) времени.

==Нахождение отрицательного цикла==
Приведенная выше реализация позволяет определить наличие в графе цикла отрицательного веса. Чтобы найти сам цикл, достаточно хранить вершины, из которых производится релаксация. 

Если после |V| - 1 итерации найдется вершина v , расстояние до которой можно уменьшить, то эта вершина либо лежит на каком-нибудь цикле отрицательного веса, либо достижима из него. Чтобы найти вершину, которая лежит на цикле, можно |V| - 1 раз пройти назад по предкам из вершины v . Так как наибольшая длина пути в графе из |V| вершин равна |V| - 1, то полученная вершина u будет гарантированно лежать на отрицательном цикле. 

Зная, что вершина u лежит на цикле отрицательного веса, можно восстанавливать путь по сохраненным вершинам до тех пор, пока не встретится та же вершина u . Это обязательно произойдет, так как в цикле отрицательного веса релаксации происходят по кругу.

 '''int[]''' negativeCycle(s)''':'''
 '''for''' v \in V
 d[v] = \mathcal {1}
 p[v] = -1
 d[s] = 0
 '''for''' i = 1 '''to''' |V| - 1
 '''for''' (u, v) \in E 
 '''if''' d[v] > d[u] + \omega(u, v)
 d[v] = d[u] + \omega(u, v)
 p[v] = u
 '''for''' (u, v) \in E 
 '''if''' d[v] > d[u] + \omega(u, v)
 '''for''' i = 0 '''to''' |V| - 1
 v = p[v]
 u = v
 '''while''' u != p[v]
 ans.add(v) // добавим вершину к ответу
 v = p[v]
 reverse(ans)
 '''break'''
 '''return''' ans

== Источники информации ==
* Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн Алгоритмы: построение и анализ — 2-е изд — М.: Издательский дом «Вильямс», 2009. — ISBN 978-5-8459-0857-5.
* [http://e-maxx.ru/algo/ford_bellman MAXimal :: algo :: Алгоритм Форда-Беллмана]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Кратчайшие пути в графах]]