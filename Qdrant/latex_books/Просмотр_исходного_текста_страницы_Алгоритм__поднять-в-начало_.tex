'''Алгоритм "поднять-в-начало"''' (англ. ''relabel-to-front'') основан на [[Метод проталкивания предпотока|методе проталкивание предпотока]], но из-за тщательного выбора порядка выполнения операций [[Метод проталкивания предпотока#Проталкивание (push)|проталкивания]] и [[Метод проталкивания предпотока#Подъем (relabel)|подъема]], время выполнения данного алгоритма составляет O(V^{3}), что асимптотически не хуже, чем O(V^{2}E).

== Допустимые ребра ==
G = (V, E) {{---}} [[Определение сети, потока#Определение сети|сеть]] с истоком s и стоком t, f {{---}} [[Метод проталкивания предпотока#Определения|предпоток]] в G, h {{---}} [[Метод проталкивания предпотока#Определения|функция высоты]].
{{Определение
|definition=
'''Допустимое ребро''' (англ. ''admissible edge'') {{---}} ребро (u, v), у которого c_{f}(u, v) > 0 и h[u] = h[v] + 1. В противном случае (u, v) называется '''недопустимым''' (англ. ''inadmissible'').
}}

{{Определение
|definition=
'''Допустимая сеть''' (англ. ''admissible network'') {{---}} сеть G_{f, h} = (V, E_{f, h}), где E_{f, h} {{---}} множество допустимых ребер.
}}

{{Лемма
|id = Лемма1
|about = Допустимая сеть является ациклической
|statement =
Допустимая сеть G_{f, h} = (V, E_{f, h}) является ациклической.
|proof =
Пусть в G_{f, h} существует [[Основные определения теории графов|циклический путь]] p = \left \langle v_0, v_1, \dots, v_k \right \rangle, где k > 0. 

 ~ ~ h[v_{i - 1}] = h[v_{i}] + 1 для i = 1, 2, \dots, k, так как каждое ребро данного пути допустимое. Просуммировав равенства вдоль циклического пути, получаем:

\sum \limits_{i = 1}^{k} h(v_{i - 1}) = \sum \limits_{i = 1}^{k} (h(v_{i}) + 1) = \sum \limits_{i = 1}^{k} h(v_{i}) + k

Вершина циклического пути p встречается при суммировании по одному разу. Значит, k = 0, что противоречит первоначальному предположению. Следовательно, допустимая сеть является ациклической.
}}

{{Лемма
|id = Лемма2
|about = Об изменении допустимой цепи с помощью операции проталкивания
|statement =
Если вершина u переполнена и ребро (u, v) допустимое, то применяемая операция push(u, v) не создает новые допустимые ребра, но может привести к тому, что ребро (u, v) станет недопустимым.
|proof =
Из u в v можно протолкнуть поток, так как ребро (u, v) допустимое, по определению. Из-за того что u {{---}} переполнена, вызываем операцию push(u, v). В результате выполнения операции может быть создано остаточное ребро (v, u). Поскольку ребро (u, v) допустимое, то h[v] = h[u] - 1, а это значит, что ребро (v, u) не может стать допустимым.

Если выполненная операция push(u, v) является насыщающим проталкиванием, то после ее выполнения c_{f}(u, v) = 0 и ребро (u, v) становится недопустимым.
}}

{{Лемма
|id = Лемма3
|about = Об изменении допустимой цепи с помощью операции подъема
|statement =
Если вершина u переполнена и не имеется допустимых ребер, выходящих из u, то применяется операция relabel(u). После подъема появляется по крайней мере одно допустимое ребро, выходящее из u, но нет допустимых ребер, входящих в u.
|proof =
Рассмотрим вершину u. Если u переполнена, то, согласно [[Метод проталкивания предпотока#Лемма2|лемме (2)]], к ней может быть применима либо операция проталкивания, либо операция подъема. А так как не существует допустимых ребер для u, то протолкнуть поток не возможно, значит, применяется операция relabel(u). После данного подъема h[u] = 1 + min \{ h[v]: (u, v) \in E_{f} \}. Значит, если u {{---}} вершина указанного множества, в которой реализуется минимум, то (u, v) становится допустимым. А это значит, что после подъема существует, хотя бы одно, допустимое ребро, выходящее из u.

Пусть, после подъема существует такая вершина u, что ребро (v, u) допустимо. Тогда после подъема h[v] = h[u] + 1, а перед ним h[v] > h[u] + 1. Но между вершинами, высоты которых отличаются более чем на 1, не существует остаточных ребер. Кроме того, подъем вершины не меняет остаточную сеть. Значит, ребро (v, u) не может находится в допустимой сети, так как оно не принадлежит остаточной сети.
}}

== Операция разгрузки (discharge) ==

'''Разгрузка''' (англ. ''discharge'') {{---}} операция, применяемая к переполненной вершине u, для того чтобы протолкнуть поток через допустимые ребра в смежные вершины, при необходимости поднимая u, делая недопустимые ребра, выходящие из вершины u, допустимыми.

Будем хранить для каждой вершины u список N[u] (список вершин, смежных с ней). То есть список N[u] содержит каждую вершину v такую, что в сети G = (V, E) ребро (u, v) \in E или (v, u) \in E. 

На первую вершину в списке указывает указатель head[N[u]]. Для перехода к следующей вершине в списке за w, поддерживается указатель next[w]. Он равен \varnothing, если w {{---}} последняя вершина в списке.

Для каждой вершины u указатель current[u] {{---}} указатель на текущую вершину списка. Изначально current[u] = head[N[u]].

 '''function''' \mathtt{discharge}(u):
 '''while''' e[u] > 0 
 v = current[u]
 '''if''' v = \varnothing
 \mathtt{relabel}(u)
 current[u] = head[N[u]]
 '''else'''
 '''if''' c(u, v) - f(u, v) > 0 '''and''' h[u] = h[v] + 1 
 \mathtt{push}(u, v) 
 '''else'''
 current[u] = next[v]

Операция завершится только тогда, когда избыток e(u) станет равным нулю, и ни подъем, ни перемещение указателя current[u] не влияет на значение e(u).

Докажем, что когда \mathtt{discharge} вызывает операции [[Метод проталкивания предпотока#Проталкивание (push)|push]] и [[Метод проталкивания предпотока#Подъем (relabel)|relable]], они применимы.

{{Лемма
|about = О применимости операции push
|id = Лемма4
|statement =
Когда \mathtt{discharge} вызывает в операцию push(u, v), то для пары вершин (u, v) применима операция проталкивания.
|proof =
Проверки операции \mathtt{discharge}, сделанные до вызова операции проталкивания, гарантируют то, что операция push будет вызвана только тогда, когда она применима. То есть e(u) > 0, c_{f}(u, v) > 0 и h(u) = h(v) + 1. 
}}

{{Лемма
|about = О применимости операции relabel
|id = Лемма5
|statement =
Когда \mathtt{discharge} вызывает в операцию relabel(u), то для вершины u применим подъем.
|proof =
Из [[Алгоритм "поднять-в-начало"#Лемма3|леммы об изменении допустимой цепи (для операции relabel)]] и условия e(u) > 0 следует, что для доказательства данной леммы необходимо показать, что все ребра, выходящие из u, являются недопустимыми.

Каждый проход операции \mathtt{discharge}(u) начинается с головы списка N[u] и оканчивается, когда current[u] = \varnothing. Именно тогда вызывается relabel(u), и начинается новый проход. К концу прохода все ребра, выходящие из u, станут недопустимыми, так как из [[Алгоритм "поднять-в-начало"#Лемма2|леммы об изменении допустимой цепи (для операции push)]] следует, что операции проталкивания не создают допустимых ребер. То есть любое допустимое ребро могло быть создано только в результате выполнения операции подъема. Но вершина u не подвергается подъему во время прохода, а любая другая вершина v, для которой вызывалась операция подъема, во время данного прохода, не имеет после подъема допустимых ребер, что следует из [[Алгоритм "поднять-в-начало"#Лемма3|леммы об изменении допустимой цепи (для операции relabel)]]. Значит, в конце прохода все ребра, выходящие из u, останутся недопустимыми.
}}

== Алгоритм ==
Инициализируем предпоток и высоты, с помощью операции [[Метод проталкивания предпотока#Схема алгоритма|\mathtt{initializePreflow}]]. Список L {{---}} список для хранения всех вершин графа, кроме стока и истока. Проинициализируем указатель current каждой вершины u, чтобы он указывал на первую вершину в списке u.

Пройдем по списку L, разгружая вершины, начиная с первой. И если операция \mathtt{discharge} изменила высоту вершины, то перемещаем ее в начало списка L. Передвинем указатель на следующую вершину списке L. Если после разгрузки была изменена высота, то берем следующую вершину в новом списке L. 

 '''function''' \mathtt{relabelToFront}(s, t): '''
 \mathtt{initializePreflow(s)}
 L = V \setminus \{ s, t \}
 '''for''' u \in V \setminus \{ s, t \}
 current[u] = head[N[u]]
 u = head[L]
 '''while''' u \ne null
 oldHeight = h[u]
 \mathtt{discharge(u)}
 '''if''' h[u] > oldHeight
 передвинуть u в начало списка L
 u = nextVertex[u]

В приведенном псевдокоде предполагается, что для каждой вершины u уже создан список N[u]. 

nextVertex[u] хранит вершину, следующую за u в списке L. Если u {{---}} последняя вершина в списке, то nextVertex[u] = null.

'''Инвариант цикла''': "при каждом выполнении условия вхождения в цикл \mathtt{while} вершины в списке L топологически упорядочены в допустимой сети G_{f, h} = (V, E_{f, h}), и ни одна вершина, стоящая в списке перед u, не имеет избыточного потока".

== Корректность алгоритма ==
Для доказательства корректности алгоритма, то есть чтобы показать что операция \mathtt{relabelToFront} вычисляет поток, покажем, что она является реализацией универсального алгоритма [[Метод проталкивания предпотока|проталкивания предпотока]]. Для начала, заметим, что она выполняет операции push и relabel только тогда, когда они применимы, следует из [[Алгоритм "поднять-в-начало"#Лемма4|лемм о применимости операций push и relabel]]. Покажем, что когда операция \mathtt{relabelToFront} завершится, не применима ни одна основная операция. Для этого подробно рассмотрим операцию \mathtt{relabelToFront}:

#После вызова \mathtt{initializePreflow} h[s] = |V| и h[u] = 0 для всех u \in V \setminus {s}. Так как |V| \geqslant 2, то ни одно ребро не является допустимым. Значит, E_{f, h} = \varnothing и любой порядок множества V \setminus \{s, t\} является топологическим упорядочением G_{f, h}.
#Проверим, что топологическое упорядочение сохранится при проведении итераций цикла \mathtt{while}. Для начала заметим, что сеть может изменится только из-за операций проталкивания и подъема. Из [[Алгоритм "поднять-в-начало"#Лемма2|леммы об изменении допустимой цепи]] нам известно, что после операции проталкивания новые допустимые ребра не появляются, а это значит, что они могли появится только во время выполнения операции подъема. После того как для вершины u применили операцию подъема, больше не существует допустимых ребер, входящих в u, но могут быть допустимые ребра, выходящие из нее. Таким образом, перемещая u в начало списка L, все допустимые ребра, выходящие из u, удовлетворяют условию топологического упорядочения.
#Проверим, что ни одна вершина, предшествующая u в списке L, не имеет избытка потока. Пусть вершина u' {{---}} вершина u на следующей итерации. 
##Если u подверглась подъему, то вершин предшествующих u' на следующей итерации, кроме u, нет или если высота u не изменилась, то там остались те же вершины, что и ранее. Так как u подверглась разгрузке, то она не содержит избытка потока. Значит, если u подверглась подъему в процессе разгрузки, то ни одна вершина, предшествующая u', не содержит избытка потока. 
##Если высота u не поменялась во время разгрузки, то вершины, стоящие в списке L перед ней, не получили избыток потока, так как L топологически упорядочен все время в процессе разгрузки, поэтому каждая операция проталкивания продвигает поток только по вершинам дальше по списку. В этом случае ни одна вершина, предшествующая u', также не имеет избытка потока.
#После завершения цикла u = null, поэтому избыток всех вершин равен 0 (инвариант цикла). Значит, ни одна основная операция неприменима.

== Оценка быстродействия ==
{{Теорема
|statement =
Время выполнения операции \mathtt{relabelToFront} для любой сети G = (V, E) составляет O(V^{3}).
|proof =
Пусть '''фаза''' {{---}} время между двумя последовательными операциями подъема. Так как всего, по [[Метод проталкивания предпотока#Лемма6|лемме (6)]], выполняется O(V^{2}) подъемов, значит, в алгоритме всего O(V^{2}) фаз.

Если операция \mathtt{discharge} не выполняет подъем, то следующий ее вызов происходит дальше по списку L (длина L меньше |V|). Если же подъем выполняется, то следующий вызов происходит уже в другой фазе алгоритма. Значит, каждая фаза содержит не более |V| вызовов \mathtt{discharge}.

Таким образом, цикл \mathtt{while} процедуры \mathtt{relabelToFront} выполняет работу (без учета операций вызываемых в \mathtt{discharge}), за O(V^{3}).

Оценим работу выполнения внутри операции \mathtt{discharge}:

#Обновление указателя current[u] выполняется O(\deg(u)) в том случае, когда вершина u подвергается подъему. Значит, для всех вершин время составляет O(V \deg(u)). Следовательно, согласно [[Лемма о рукопожатиях|лемме о рукопожатиях]], время равно O(VE).
#Пусть u {{---}} произвольная вершина сети. Она может быть поднята не более O(V) раз, время каждого подъема O(\deg(u)). Значит, время всех подъемов ограничивается O(VE).
#Из [[Метод проталкивания предпотока#Лемма8|леммы (8)]] следует, что количество насыщающих проталкиваний составляет O(VE). Ненасыщающее проталкивание уменьшает избыток до 0, после чего разгрузка останавливается. Следовательно, ненасыщающих проталкиваний не больше, чем вызовов \mathtt{discharge}, то есть O(V^{3}).

Таким образом, время выполнения операции \mathtt{relabelToFront} составляет O(V^{3} + VE), что эквивалентно O(V^{3}).
}}

==См. также==
* [[Метод проталкивания предпотока]]
* [[Теорема Форда-Фалкерсона]]
* [[Алгоритм Форда-Фалкерсона, реализация с помощью поиска в глубину]]
* [[Схема алгоритма Диница]]
* [[Алоритм Эдмондса-Карпа]]

== Источники информации ==
* Кормен Т., Лейзерсон Ч., Ривест Р. Алгоритмы: построение и анализ. — 2-е изд. — М.: Издательский дом «Вильямс», 2011. — С. 774—785.
* [http://ru.wikipedia.org/wiki/Алгоритм_проталкивания_предпотока Алгоритм проталкивания предпотока — Википедия]
*[http://e-maxx.ru/algo/preflow_push_faster MAXimal::algo::Модификация метода Проталкивания предпотока для нахождения максимального потока за O (N3)]
[[Категория: Алгоритмы и структуры данных]]
[[Категория: Задача о максимальном потоке]]