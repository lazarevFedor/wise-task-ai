'''''Венгерский алгоритм''''' (англ. ''Hungarian algorithm'') — алгоритм, решающий задачу о назначениях за полиномиальное время. Оригинальная версия была придумана и разработана Х. Куном в 1955 году и имела асимптотику O(n^4) , но позже Эдмонс и Карп (а также, независимо от них, Томидзава) показали, что можно улучшить ее до O(n^3) .
{{Задача
|definition = Пусть дан [[Основные определения теории графов|взвешенный полный двудольный граф]] c целыми весами ребер K_{n, n} , нужно найти в нем [[Паросочетания: основные определения, теорема о максимальном паросочетании и дополняющих цепях|полное паросочетание минимального веса]]. Вес паросочетания определяется как сумма весов его ребер. Далее будем обозначать левую и правую доли графа за X и Y соответственно, вес ребра xy — как c(xy) .
}}

== Вспомогательные леммы ==

{{Лемма
|statement=
Если веса всех ребер графа, инцидентных какой-либо вершине, изменить (увеличить или уменьшить) на одно и то же число, то в новом графе оптимальное паросочетание будет состоять из тех же ребер, что и в старом.
|proof=
Полное паросочетание для каждой вершины содержит ровно одно ребро, инцидентное этой вершине. Указанная операция изменит на одно и то же число вес любого паросочетания. Значит, ребро, которое принадлежало оптимальному паросочетанию в старом графе, в новом графе тоже будет ему принадлежать.
}}

Далее будем рассматривать только графы с неотрицательной весовой функцией, так как, согласно этой лемме, задачу о назначениях на остальных графах можно свести к задаче о назначениях на них.

{{Лемма
|statement=
Выделим в множествах X и Y подмножества X', Y'. Пусть d = \min \{c(xy) \mid x \in X \setminus X', y \in Y'\}. Прибавим d ко всем весам ребер, инцидентных вершинам из X'. Затем отнимем d от всех весов ребер, инцидентных вершинам из Y' (далее для краткости эта операция обозначается как X' \uparrow\downarrow Y' ). Тогда:
# Веса всех ребер графа останутся неотрицательными.
# Веса ребер вида xy, где x \in X', y \in Y' или x \in X \backslash X', y \in Y \backslash Y', не изменятся.
|proof=
Рассмотрим матрицу весов графа. Не умаляя общности, можно сказать, что множества X' и Y' состоят из первых элементов множеств X и Y соответственно (мы упорядочиваем множества по номерам вершин). Тогда вся матрица делится на 4 блока:

 
 
 Y' 
 Y \backslash Y' 
 
 
 X' 
 A + d - d 
 C + d 
 
 
 X \backslash X' 
 B - d 
 D 
 

Веса группы A будут сначала увеличены, а потом уменьшены на d , поэтому они не изменятся, веса группы D вообще изменяться не будут. Все веса группы B будут уменьшены на d , но d — минимум среди этих весов, поэтому они останутся неотрицательными.

}}

{{Лемма
|statement=
Если веса всех ребер графа неотрицательны и некоторое полное паросочетание состоит из ребер нулевого веса, то оно является оптимальным.
|proof=
Действительно, паросочетание с какими-то другими весами ребер имеет больший вес и оптимальным не является.
}}

== Общий метод ==

Доказанные ранее утверждения позволяют придумать схему алгоритма, решающего задачу о назначениях: нужно найти полное паросочетание из ребер нулевого веса в графе, полученном из исходного преобразованиями, описанными в первых двух леммах. 

Алгоритм, решающий задачу, работает с графом, как с матрицей весов.

* Вычитаем из каждой строки значение ее минимального элемента. Теперь в каждой строке есть хотя бы один нулевой элемент.
* Вычитаем из каждого столбца значение его минимального элемента. Теперь в каждом столбце есть хотя бы один нулевой элемент.
* Ищем в текущем графе полное паросочетание из ребер нулевого веса: 
** Если оно найдено, то желаемый результат достигнут, алгоритм закончен.
** В противном случае, покроем нули матрицы весов минимальным количеством строк и столбцов (это не что иное, как [[Связь максимального паросочетания и минимального вершинного покрытия в двудольных графах|нахождение минимального вершинного покрытия в двудольном графе]]). Пусть X_c и Y_c — множества вершин минимального вершинного покрытия из левой и правой долей (то есть, строк и столбцов) соответственно, тогда применим преобразование X_c \uparrow\downarrow (Y \setminus Y_c) . Для этого преобразования d будет минимумом по всем ребрам между X \setminus X_c и Y \setminus Y_c , то есть, ребер нулевого веса здесь нет, поэтому, после его выполнения в матрице весов появится новый нуль. После этого перейдем к шагу 1.

== Анализ времени работы ==

[[Алгоритм Форда-Фалкерсона для поиска максимального паросочетания|Поиск максимального паросочетания]] или [[Связь максимального паросочетания и минимального вершинного покрытия в двудольных графах|минимального вершинного покрытия]] в двудольном графе совершается за O(n^3) операций. При каждом повторении шагов 1-4 в матрице весов появляется новый нуль. Этот нуль соответствует некоторому новому ребру между вершинами из множеств X \setminus X_c и Y \setminus Y_c . Всего в графе n^2 ребер, значит, всего будет совершено не более O(n^2) итераций внешнего цикла. Поэтому, верхняя оценка времени работы данного метода — O(n^5) . Более точная оценка довольно сложна и зависит от порядка чисел в матрице весов графа.

== Алгоритм за O(n^3) ==

=== Общая идея ===
Будем добавлять в рассмотрение строки матрицы одну за одной, а не рассматривать их все сразу.

=== Описание алгоритма ===
* Начало
* '''Шаг 0.''' Введем ''следующее понятие'':
: Назовём потенциалом два произвольных массива чисел u[1 \ldots n] и v[1 \ldots n] таких, что выполняется условие:
 u[i] + v[j] \leqslant a[i][j] ~ (i = 1 \ldots n), где a {{---}} заданная матрица. 
* '''Шаг 1.''' Добавляем в рассмотрение очередную строку матрицы a. 
* '''Шаг 2.''' Пока нет увеличивающей цепи, начинающейся в этой строке, пересчитываем потенциал.
* '''Шаг 3.''' Как только появляется увеличивающая цепь, чередуем паросочетание вдоль неё (включая тем самым последнюю строку в паросочетание), и переходим к началу (к рассмотрению следующей строки).
* Конец

=== Ключевые идеи ===
* Для проверки наличия увеличивающей цепочки нет необходимости запускать обход Куна заново после каждого пересчёта потенциала. Вместо этого можно оформить [[Алгоритм Куна для поиска максимального паросочетания|обход Куна]] в итеративном виде: после каждого пересчёта потенциала мы просматриваем добавившиеся жёсткие рёбра и, если их левые концы были достижимыми, помечаем их правые концы также как достижимые и продолжаем обход из них.
* Развивая эту идею дальше, можно прийти к такому представлению алгоритма: это цикл, на каждом шаге которого сначала пересчитывается потенциал, затем находится столбец, ставший достижимым (а таковой всегда найдётся, поскольку после пересчёта потенциала всегда появляются новые достижимые вершины), и если этот столбец был ненасыщен, то найдена увеличивающая цепь, а если столбец был насыщен — то соответствующая ему в паросочетании строка также становится достижимой.
* Теперь алгоритм принимает вид: цикл добавления столбцов, на каждом из которых сначала пересчитывается потенциал, а затем какой-то новый столбец помечается как достижимый.
* Чтобы быстро пересчитывать потенциал (быстрее, чем наивный вариант за O(n^2) ), надо поддерживать вспомогательные минимумы по каждому из столбцов j .

=== Реализация ===

 \mathtt{a[1 \dots n][1 \dots m]} {{---}} прямоугольная входная матрица, где \mathtt{n \leqslant m} . Матрица хранится в 1-индексации.

 \mathtt{u[0 \dots n], ~ v[0 \dots n]} {{---}} потенциал.

 \mathtt{p[0 \dots m]} {{---}} массив паросочетания. Для каждого стобца \mathtt{i = 0 \dots m} он хранит номер соответствующей выбранной строки \mathtt{p[i]} (или \mathtt{0} , если ничего не выбрано). Полагаем, что \mathtt{p[0]} равно номеру рассматриваемой строки.

 \mathtt{minv[1 \dots m]} {{---}} массив, хранящий для каждого столбца \mathtt{j} вспомогательные минимумы, необходимые для быстрого пересчета потенциала.

 \mathtt{minv[j] = \min\limits_{i \in Z_1}(a[i][j] - u[i] - v[j])} , где \mathtt{Z_1} {{---}} множество вершин первой доли, которые были посещены обходом [[Алгоритм Куна для поиска максимального паросочетания|алгоритма Куна]] при попытке поиска увеличивающей цепи.

 \mathtt{way[1 \dots m]} {{---}} массив, содержащий информацию о том, где эти минимумы достигаются, чтобы мы могли впоследствии восстановить [[Паросочетания: основные определения, теорема о максимальном паросочетании и дополняющих цепях|увеличивающую цепочку]].

 '''function''' hungarianAlgorithm(a):
 '''for''' i = 1 '''to''' n // рассматриваем строки матрицы ''a'' 
 p[0] = i // для удобства реализации 
 j0 = 0 // свободный столбец 
 заполняем массивы ''minv'' {{---}} \infty , ''used'' {{---}} ''false''
 '''while''' ''true'' // ищем свободный столбец 
 used[j0] = ''true'', i0 = p[j0] // помечаем посещенными столбец ''j0'' и строку ''i0'' 
 пересчитываем массив ''minv'', находим в нем минимум '' \delta '' (изначально '' \infty '') и столбец ''j1'', в котором он достигнут
 '''for''' j = 0 '''to''' m // производим пересчет потенциала ''u'' и ''v'', соответствующее изменение ''minv'' 
 '''if''' used[j]
 u[p[j]] += \delta 
 v[j] -= \delta 
 '''else'''
 minv[j] -= \delta 
 если нашли свободный столбец {{---}} выходим из цикла
 ищем увеличивающуюся цепочку, пользуясь массивом предков ''way''

=== Время работы ===
Оценим время работы алгоритма. Во внешнем цикле мы добавляем в рассмотрение строки матрицы одну за другой. Каждая строка обрабатывается за время O(n^2) , поскольку при этом могло происходить лишь O(n) пересчётов потенциала (каждый — за время O(n) ), для чего за время O(n^2) поддерживается массив minv ; [[Алгоритм Куна для поиска максимального паросочетания|алгоритм Куна]] суммарно отработает за время O(n^2) (поскольку он представлен в форме O(n) итераций, на каждой из которых посещается новый столбец).

Итоговая асимптотика составляет O(n^3) .

== См. также ==
* [[Алгоритм Куна для поиска максимального паросочетания]]
* [[Связь максимального паросочетания и минимального вершинного покрытия в двудольных графах]]

== Источники информации ==
* Асанов М., Баранский В., Расин В. — Дискретная математика: Графы, матроиды, алгоритмы — 2010, 368 стр.
* [http://ru.wikipedia.org/wiki/Венгерский_алгоритм Венгерский алготитм в Википедии]
* [http://rain.ifmo.ru/cat/view.php/vis/graph-flow-match/hungarian-2002 Визуализатор алгоритма]
* [http://acm.mipt.ru/twiki/bin/view/Algorithms/HungarianAlgorithmCPP?sortcol=5&table=2&up=0 Реализация венгерского алгоритма на C++]
* [http://e-maxx.ru/algo/assignment_hungary Венгерский алгоритм решения задачи о назначениях]

[[Категория:Алгоритмы и структуры данных]]
[[Категория: Задача о потоке минимальной стоимости]]