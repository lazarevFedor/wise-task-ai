==Теорема==
{{Теорема
|about=
о декомпозиции
|statement=
Пусть G = (V, E) — [[Определение сети, потока#flow_network|транспортная сеть]], f — [[Определение сети, потока#flow|поток]] в G. Тогда |f| можно представить в виде совокупности O(E) путей из истока в сток и циклов: |f| = \sum\limits_{i=1}^{}c_{i}\cdot f(p_{i}) + \sum\limits_{j=1}^{}d_{j}\cdot f(k_{j}), где p_{i} — путь из s в t, k_{j} — цикл, c_{i} и d_{j} — константы.
|proof=
Пусть s — исток, t — сток сети G. Пусть из s выходит хотя бы одно ребро с положительным потоком. Пойдем по этому ребру, попадем в вершину v_1. Если v_1 совпадает с t, то найденный путь является путем из s в t, иначе по закону сохранения потока для вершины v_1 из неё должно выходить хотя бы одно ребро с положительным потоком в некоторую вершину v_2. Будем продолжать этот процесс до тех пор, пока v_i не совпадет с t (найден путь p_{i} из s в t) либо с одной из ранее посещенных вершин (найден цикл k_{j}). Данный путь (цикл) будет иметь положительный поток f(p_{i}) или f(k_{j}), равный минимальному среди потоков по всем рёбрам пути (цикла). Уменьшая поток каждого ребра этого пути (цикла) на величину f(p_{i}) или f(k_{j}), получаем новый поток. Будем продолжать описанный алгоритм до тех пор, пока поток из s не станет нулевым. Потребуем теперь, чтобы потоки из других вершин стали нулевыми. Для этого повторим поиск циклов вышеописанным способом для других вершин. Итак, поскольку потоки по всем рёбрам равны нулю, то мы получили искомую декомпозицию потока. Заметим, что после поиска одного пути (цикла) поток хотя бы по одному из рёбер обнулится, следовательно, для полного представления потока потребуется не более E таких операций.
}}

==Алгоритм==
Рассмотрим алгоритм, описанный в доказательстве теоремы. Построение декомпозиции потока можно записать с помощью псевдокода (на вход подается сеть G = (V, E)):

===Псевдокод===
 '''function''' simpleDecomposition(s):
 Q = \varnothing // множество пройденных рёбер
 P = \varnothing // множество посещённых вершин
 v = s
 '''while''' v \notin P 
 '''if''' v = t 
 '''break'''
 edge e = \varnothing
 '''for''' u : (v,u) \in E
 '''if''' f(v,u)>0 
 e = (v,u)
 '''break'''
 '''if''' e = \varnothing
 '''return''' \varnothing
 Q.push_back(e)
 P = P \cup \{v\}
 v = u 
 '''if''' v \in P // нашли цикл, удаляем из Q все рёбра, найденные до того, как v была включена в P
 '''while''' (Q.begin.from \neq v)
 Q.pop_front()
 f(Q) = f(Q) - \min\limits_{(u,v) \in Q}f(u,v) 
 '''return''' (f, Q)
 
 '''function''' fullDecomposition():
 d = \varnothing // собственно, декомпозиция графа: совокупность подмножеств, которые являются путями/циклами, и их поток
 p = simpleDecomposition(s) // один из путей/циклов в графе и его поток
 '''while''' (p \neq \varnothing)
 d = d \cup p 
 p = simpleDecomposition(s)
 '''for''' u \in V 
 p = simpleDecomposition(u)
 '''while''' (p \neq \varnothing)
 d = d \cup \{p\} 
 p = simpleDecomposition(u)
 '''return''' d

===Анализ работы алгоритма===
{{Утверждение
|statement=
Время работы алгоритма поиска декомпозиции потока, описанного выше, равно O(VE).
|proof=
Действительно, каждый путь (цикл) содержит не более V вершин, следовательно, поиск пути (цикла) работает за O(V). Т. к. декомпозиция потока содержит O(E) путей, то всего в ходе алгоритма при рассмотрении всех вершин будет осуществлено O(E) поисков путей (циклов) (в остальных случаях в силу отсутствия потока через вершину поиск пути вызываться не будет). Итого суммарное время работы составит O(VE).}}

==Источники==
* ''Ravindra Ahuja, Thomas Magnanti, James Orlin'' — '''Network flows''' — Prentice-Hall, Inc. Upper Saddle River, New Jersey, 1993.

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Задача о максимальном потоке ]]