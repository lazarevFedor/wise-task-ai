== Алгоритм ==
Пусть дана [[Определение_сети,_потока#.D0.9E.D0.BF.D1.80.D0.B5.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81.D0.B5.D1.82.D0.B8|сеть]] G , все рёбра которой имеют целочисленную [[Определение_сети,_потока#.D0.9E.D0.BF.D1.80.D0.B5.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81.D0.B5.D1.82.D0.B8|пропускную способность]]. Обозначим за U максимальную пропускную способность: U = \max\limits_{(u, v) \in E} c(u, v) .

Идея алгоритма заключается в нахождении путей с высокой пропускной способностью в первую очередь, чтобы сразу сильно увеличивать [[Определение_сети,_потока#.D0.9E.D0.BF.D1.80.D0.B5.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0|поток]] по ним, а затем по всем остальным. Для этого воспользуемся масштабом \Delta . Изначально положим \Delta = 2^{\lfloor \log_2 U \rfloor} .

На каждой итерации в [[Дополняющая_сеть,_дополняющий_путь|дополняющей сети]] алгоритм находит [[Дополняющая_сеть,_дополняющий_путь|дополняющие пути]] с пропускной способностью не меньшей \Delta и увеличивает поток вдоль них.
Уменьшив масштаб \Delta в 2 раза, переходит к следующей итерации.

Очевидно, что при \Delta = 1 алгоритм вырождается в алгоритм [[Алоритм_Эдмондса-Карпа|Эдмондса-Карпа]], вследствие чего является корректным.

Количество необходимых увеличений путей, основанных на кратчайших путях, может быть много больше количества увеличений, основанных на путях с высокой пропускной способностью.
{|border="0" cellpadding="5" width=30% align=center
|[[Файл:Flow_scale_1.png|550px|thumb|center|Выбор дополняющих путей в порядке длины]]
|[[Файл:Flow_scale_2.png|550px|thumb|center|Выбор пути с высокой пропускной способностью в первую очередь]]
|}

== Оценка времени работы ==
{{Лемма
|about=
1
|statement=
Максимальный поток в сети G ограничен сверху значением |f_k| + 2^k E , где |f_k| {{---}} значение потока при масштабе \Delta = 2^k .
|proof=
[[Файл:Flow_scale_3.png|530px|thumb|right|Разрез C_k ]]

В конце итерации с масштабом \Delta = 2^k , сеть G_{f_k} может быть разбита на два непересекающихся множества A_k и \overline{A_k} так, что остаточная пропускная способность каждого ребра, идущего из A_k в \overline{A_k} , не превосходит масштаба \Delta . То есть образуется [[Разрез,_лемма_о_потоке_через_разрез|разрез]] C_k = \langle A_k, \overline{A_k} \rangle .

При этом, количество таких рёбер не превосходит E .
Значит, значение остаточного потока не может превосходить \Delta E = 2^k E .
}}

{{Лемма
|about=
2
|statement=
Суммарное количество увеличивающих путей {{---}} O(E \log U) .
|proof=
На некоторой итерации алгоритма каждый дополняющий путь имеет пропускную способность не меньше 2^k .
Дополняющий поток на предыдущем шаге ограничен значением 2^{k + 1} E . Следовательно, на каждой итерации количество дополняющих путей не превосходит 2E .}}
{{Утверждение
|statement=
Время работы алгоритма {{---}} O(E^2 \log U) .
|proof=
В ходе выполнения алгоритма масштаб \Delta принимает следующие значения: S = \{2^{\lfloor \log_2 U \rfloor}, \ldots, 2^k, \ldots, 2, 1, 0\} . Тогда |S| = O(\log U) {{---}} количество итераций алгоритма.

Количество итераций алгоритма {{---}} O(\log U) , значит, суммарное количество увеличивающих путей {{---}} O(E \log U) .

Алгоритм [[Обход_в_ширину|обхода в ширину]] находит каждый дополняющий путь за время O(E) . Следовательно, суммарное время работы алгоритма {{---}} O(E^2 \log U) .}}

== Псевдокод ==
 '''function''' maxFlowByScaling(G: '''graph''', s: '''int''', t: '''int'''): '''int'''
 '''int''' flow = 0 // поток в сети 
 '''int''' scale = 2^{\lfloor\log_2U\rfloor} // текущий минимальный размер потока, который пытаемся пустить 
 '''while''' scale \geqslant 1
 '''while''' в G_f существует увеличивающий путь p с пропускной способностью не меньше, чем scale
 '''int''' minCapacity = \min\{c(u, v) \colon(u, v) \in p\} // минимальная пропускная способность в увеличивающем пути 
 увеличить поток по рёбрам p на minCapacity
 обновить G_f 
 flow = flow + minCapacity
 scale = scale / 2
 '''return''' flow

== См. также ==
* [[Определение_сети,_потока|Определение сети, потока]]
* [[Алоритм_Эдмондса-Карпа|Алоритм Эдмондса-Карпа]]
* [[Алгоритм_Форда-Фалкерсона,_реализация_с_помощью_поиска_в_глубину|Алгоритм Форда-Фалкерсона]]

== Источники информации ==
* [http://www.csd.uwo.ca/~yuri/Papers/iccv07_cap_scaling.pdf ''Olivier Juan, Yuri Boikov'': Capacity Scaling for Graph Cuts in Vision]
* [http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=maxFlowRevisited Algorithm Tutorials. Maximum Flow: Augmenting Path Algorithms Comparison]
* [http://logic.pdmi.ras.ru/ics/talks/21stream.pdf ''Андрей Станкевич'': Задача о максимальном потоке]
* [https://youtu.be/sEwp5ZAJJps?t=18m9s ''Андрей Станкевич'': Лекториум, дополнительные главы алгоритмов, лекция 12]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Задача о максимальном потоке]]