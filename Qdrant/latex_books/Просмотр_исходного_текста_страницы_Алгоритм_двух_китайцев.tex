'''Алгоритм двух китайцев''' — алгоритм построения минимального остовного дерева во взвешенном ориентированном графе с корнем в заданной вершине. Был разработан математиками Чу Йонджином и Лю Цзенхонгом.

== Постановка задачи ==

Дан взвешенный ориентированный граф G(V, E) и начальная вершина v. Требуется построить корневое остовное дерево в G с корнем в вершине v, сумма весов всех ребер которого минимальна.

== Алгоритм ==

=== Описание ===

Если хотя бы одна вершина графа G недостижима из v, то требуемое дерево построить нельзя.

{|
|-
|width="70%"|
# Для каждой вершины u \ne v графа G произведём следующую операцию: найдём ребро минимального веса, входящее в u, и вычтем вес этого ребра из весов всех рёбер, входящих в u. m(u) = \min \limits_{tu \in E}w(tu), w'(tu) = w(tu) - m(u).
# Строим граф K = (V,K_0), где K_0 — множество рёбер нулевого веса графа G c весовой функцией w'. Если в этом графе найдётся остовное дерево с корнем в v, то оно и будет искомым.
# Если такого дерева нет, то построим граф C — конденсацию графа K. Пусть y и z — две вершины графа C, отвечающие компонентам сильной связности Y и Z графа K соответственно. Положим вес ребра между вершинами y и z равным минимальному среди весов рёбер графа G с весовой функцией w', идущих из Y в Z.
# Продолжим с пункта 2, используя граф C вместо G.
# В C построено MST T. Построим теперь MST T' в G с весовой функцией w'. Добавим к T' все вершины компоненты сильной связности графа K, которой принадлежит v (по путям нулевого веса из v). Пусть в T есть ребро yz, где y отвечает компоненте сильной связности Y, а z — компоненте сильной связности Z графа K. Между Y и Z в графе G с весовой функцией w' есть ребро y'z', вес которого равен весу ребра yz. Добавим это ребро к дереву T'. Добавим к T' все вершины компоненты Z по путям нулевого веса из z'. Сделаем так для каждого ребра дерева T.
# Полученное дерево T' — MST в графе G.
|
|}

=== Пример ===

{| class = "wikitable" width="70%"
|-
! Описание !! Изображение 
|-
|Исходный граф.
|[[Файл:китайГраф1.png|200px]]
|-
|Произведем спуск до нулевых ребер (Фаза 1, 2).
|[[Файл:китайГраф2.png|200px]]
|-
|По нулевым ребрам нельзя дойти до всех вершин из v, поэтому строим конденсацию и добавляем наименьшие ребра между компонентами (Фаза 3).
Найдем MST для данного графа.
|[[Файл:китайГраф3.png|200px]]
|-
|Произведем спуск до нулевых ребер (Фаза 1, 2).
|[[Файл:китайГраф4.png|200px]]
|-
|По нулевым ребрам нельзя дойти до всех вершин из v, поэтому строим конденсацию и добавляем наименьшие ребра между компонентами (Фаза 3).
Найдем MST для данного графа.
|[[Файл:китайГраф5.png|200px]]
|-
|Произведем спуск до нулевых ребер (Фаза 1, 2). По полученным нулевым ребрам можно дойти из корня до всех вершин. Тогда запускаем dfs из корня и возвращаем ребра.
|[[Файл:китайГраф6.png|200px]]
|-
|Находим корень в каждой из компонент, из каждого такого корня запускаем dfs по нулевым ребрам, возвращаем результат.
|[[Файл:китайГраф7.png|200px]]
|-
|Находим корень в каждой из компонент, из каждого такого корня запускаем dfs по нулевым ребрам. Полученое дерево и есть MST в исходном графе.
|[[Файл:китайГраф8.png|200px]]
|}

=== Корректность ===

''' Замечания: '''
* После перевзвешивания в каждую вершину кроме v входит по крайней мере одно ребро нулевого веса.
* Пусть T — искомое дерево в G с весовой функцией w. w'(T) = w(T) - \sum \limits_{u \in V \setminus v}m(u), т.е. T - MST в G с весовой функцией w тогда и только тогда, когда T — MST в G с весовой функцией w'.

{{Лемма

|statement=
Кратчайшее дерево путей T' в графе G можно получить, найдя кратчайшее дерево путей T в графе C, а затем заменив в нем каждую компоненту сильной связности деревом, построенным из дуг нулевой длинны.
|proof=
Зафиксируем любое дерево путей и покажем, что в графе G найдется дерево не большей длины, имеющее такую структуру, как сказано в лемме. Для такой структуры дерева необходимо и достаточно, чтобы в каждое из подмножеств входило только по одному ребру. Меньше быть не может, иначе получится отдельная компонента связности. Если же в какое-то подмножество входит больше чем одно ребро, то все ребра кроме одного можно заменить ребрами нулевой длины, лежащими внутри подмножества, что разве лишь уменьшит длину дерева и не нарушит связности. Повторяя это преобразование нужное число раз мы добьемся искомой структуры дерева.
}}

Из сделанных замечаний и леммы следует, что дерево T' — MST в G.

=== Реализация ===

Обозначения:
*Граф хранится в виде множества ребер + индекс корня.
*Множество ребер - список смежности.
*Ребро - структура {from, to, weight}.
*root - текущий корень.
 
Особенность реализации: алгоритму не важна кратность ребер, поэтому при составлении нового графа кратные ребра могут
появиться - это уменьшает асимптотику с O(V^2) до O(E) 
 
 Проверяем, можно ли дойти из v до остальных вершин. Если можно - запускаем findMST.
 
 int findMST(edges, n, root):
 int res = 0
 int minEdge[n] // создаем массив минимумов, входящих в каждую компоненту, инициализируем бесконечностью.
 for each e \in edges
 minEdge[e.to] = min(e.w, minEdge[e.to])
 for each v \in V \backslash \{root\}
 res += minEdge[v] //веса минимальных ребер точно будут в результате
 edge zeroEdges[] //создаем массив нулевых ребер
 for each e \in edges
 if e.w == minEdge[e.to]
 zeroEdges.pushback(e_1) // e_1 - ребро е, уменьшенное на минимальный вес, входящий в e.to
 if dfs(root, zeroEdges) // проверяем, можно ли дойти до всех вершин по нулевым ребрам
 return res
 int newComponents[n] // будущие компоненты связности
 newComponents = Сondensation(zeroEdges) 
 edge newEdges[] //создаем массив ребер в новом графе с вершинами в полученных компонентах
 for each e \in edges
 if e.to и e.from в разных компонентах
 добавляем в newEdges ребро с концами в данных компонентах и весом e.w - minEdge[e.to]
 res += findMST(newEdges, ComponentsCount, newComponents[root])
 return res

=== Сложность ===
Всего будет построено не более V конденсаций. Конденсацию можно построить за O(E). Значит, алгоритм можно реализовать за O(VE).

== Источники ==
*Романовский И. В. '''Дискретный анализ''', 3-е изд., перераб. и доп. - СПб.:Невский Диалект; БХВ-Петербург, 2003. - 320 с.: ил. - '''ISBN 5-7940-0114-3'''
* [http://is.ifmo.ru/vis/ctree/ http://is.ifmo.ru]

==См. также==
* [[Алгоритм Борувки]]
* [http://en.wikipedia.org/wiki/Edmonds%27_algorithm Edmonds' Algorithm]
* [http://rain.ifmo.ru/cat/view.php/vis/graph-spanning-trees/shortest-tree-chinese-2003 Визуализатор алгоритма]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Остовные деревья ]]