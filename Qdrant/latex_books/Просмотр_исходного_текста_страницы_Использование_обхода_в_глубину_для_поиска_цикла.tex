{{Задача
|definition = Дан граф, требуется проверить наличие [[Основные определения теории графов|цикла]] в этом графе.
}}

== Алгоритм ==

Будем решать задачу с помощью [[Обход в глубину, цвета вершин|поиска в глубину]].

В случае ориентированного графа произведём серию обходов. То есть из каждой вершины, в которую мы ещё ни разу не приходили, запустим поиск в глубину, который при входе в вершину будет красить её в серый цвет, а при выходе из нее {{---}} в чёрный. И, если алгоритм пытается пойти в серую вершину, то это означает, что цикл найден.

В случае неориентированного графа, одно ребро не должно встречаться в [[Основные определения теории графов#def_no_graph_path|цикле]] дважды по определению. Поэтому необходимо дополнительно проверять, что текущее рассматриваемое из вершины ребро не является тем ребром, по которому мы пришли в эту вершину.

Заметим, что, если в графе есть вершины с петлями, то алгоритм будет работать корректно, так как при запуске поиска в глубину из такой вершины, найдется ребро, ведущее в нее же, а значит эта петля и будет являться циклом.

Для восстановления самого цикла достаточно при запуске поиска в глубину из очередной вершины добавлять эту вершину в [[Стек|стек]]. Когда поиск в глубину нашел вершину, которая лежит на цикле, будем последовательно вынимать вершины из стека, пока не встретим найденную еще раз. Все вынутые вершины будут лежать на искомом цикле.

Асимптотика поиска цикла совпадает с асимптотикой поиска в глубину {{---}} O(|V| + |E|).

[[Файл: Dfs_cycle.png|thumb|200px|right| Момент нахождения цикла: синие ребра {{---}} уже пройденные, красное ребро ведет в серую, уже пройденную, вершину.]]

== Доказательство ==

Пусть дан граф G. Запустим \mathrm{dfs}(G). Рассмотрим выполнение процедуры поиска в глубину от некоторой вершины v . Так как все серые вершины лежат в стеке рекурсии, то для них вершина v достижима, так как между соседними вершинами в стеке есть ребро. Тогда, если из рассматриваемой вершины v существует ребро в серую вершину u , то это значит, что из вершины u существует путь в v и из вершины v существует путь в u состоящий из одного ребра. И так как оба эти пути не пересекаются, то цикл существует.

Докажем, что если в графе G существует цикл, то \mathrm{dfs}(G) его всегда найдет. Пусть v {{---}} первая вершина принадлежащая циклу, рассмотренная поиском в глубину. Тогда существует вершина u , принадлежащая циклу и имеющая ребро в вершину v . Так как из вершины v в вершину u существует белый путь (они лежат на одном цикле), то по [[Лемма о белых путях|лемме о белых путях]] во время выполнения процедуры поиска в глубину от вершины u , вершина v будет серой. Так как из u есть ребро в v , то это ребро в серую вершину. Следовательно \mathrm{dfs}(G) нашел цикл.

== Реализация для случая ориентированного графа ==
 // color {{---}} массив цветов, изначально все вершины белые 
 '''func''' dfs(v: '''vertex'''): // v {{---}} вершина, в которой мы сейчас находимся 
 color[v] = grey 
 '''for''' (u: vu \in E)
 '''if''' (color[u] == white)
 dfs(u)
 '''if''' (color[u] == grey)
 print() // вывод ответа 
 color[v] = black

== См. также ==
* [[Использование обхода в глубину для проверки связности]]
* [[Использование обхода в глубину для топологической сортировки]]
* [[Использование обхода в глубину для поиска компонент сильной связности]]
* [[Использование обхода в глубину для поиска точек сочленения]]
* [[Использование обхода в глубину для поиска мостов]]

== Источники информации ==
* [http://e-maxx.ru/algo/finding_cycle MAXimal :: algo {{---}} «Проверка графа на ацикличность и нахождение цикла»]
* [http://shujkova.ru/sites/default/files/algorithm2.pdf Прикладные задачи алгоритма DFS]
* ''Кормен Т., Лейзерсон Ч., Ривест Р.'' Алгоритмы: построение и анализ.[http://wmate.ru/ebooks/?dl=380&mirror=1] — 2-е изд. — М.: Издательский дом «Вильямс», 2007. — С. 1296.

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Обход в глубину]]