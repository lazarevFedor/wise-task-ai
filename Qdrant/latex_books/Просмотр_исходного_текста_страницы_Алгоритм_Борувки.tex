Алгоритм Борувки (англ. ''Borůvka's algorithm'') {{---}} алгоритм поиска [[Остовные деревья: определения, лемма о безопасном ребре | минимального остовного дерева]] во взвешенном неориентированном связном графе.
Впервые был опубликован в 1926 году Отакаром Борувкой.

==Описание алгоритма==

Алгоритм состоит из нескольких шагов:

# Изначально каждая вершина графа G {{---}} тривиальное дерево, а ребра не принадлежат никакому дереву.
# Для каждого дерева T найдем минимальное инцидентное ему ребро. Добавим все такие ребра.
# Повторяем шаг 2 пока в графе не останется только одно дерево T . 

Данный алгоритм может работать неправильно, если в графе есть ребра равные по весу. Например, полный граф из трех вершин, вес каждого ребра равен один. В T могут быть добавлены все три ребра. Избежать эту проблему можно, например, выбирая в первом пункте среди ребер, равных по весу, ребро с наименьшим номером.

==Доказательство корректности==

{{Теорема
|statement= Алгоритм Борувки строит '''MST'''.
|proof=Очевидно, что в результате работы алгоритма получается дерево. Пусть T {{---}} минимальное остовное дерево графа G , а T' {{---}} дерево полученное после работы алгоритма.

Покажем, что T = T'. 

Предположим обратное T \neq T' . Пусть ребро e' {{---}} первое добавленное ребро дерева T' , не принадлежащее дереву T . Пусть P {{---}} путь, соединяющий в дереве T вершины ребра e' . 

Понятно, что в момент, когда ребро e' добавляли, какое-то ребро P (назовем его e ) не было добавлено. По алгоритму w(e) \geqslant w(e') . Однако тогда T - e + e' {{---}} остовное дерево веса не превышающего вес дерева T . Получили противоречение. Следовательно T = T'.
}}

==Реализация==
У вершины есть поле \mathtt{comp} {{---}} компонента связности, которой принадлежит эта вершина.

{| width = 100%
|-
| 
 // G {{---}} исходный граф
 // w {{---}} весовая функция
 '''function''' \mathtt{boruvkaMST}():
 '''while''' T\mathtt{.size} 
 '''for''' k \in Component // Component {{---}} множество компонент связности в T. Для 
 w(\mathtt{minEdge}[k])=\infty // каждой компоненты связности вес минимального ребра = \infty.
 \mathtt{findComp(}T\mathtt{)} // Разбиваем граф T на компоненты связности обычным ''dfs''-ом.
 '''for''' \mathtt{(u,v)} \in E 
 '''if''' \mathtt{u.comp} \neq \mathtt{v.comp}
 '''if''' w(\mathtt{minEdge}[\mathtt{u.comp}]) > w(u,v)
 \mathtt{minEdge}[\mathtt{u.comp}] = (u,v)
 '''if''' w(\mathtt{minEdge}[\mathtt{v.comp}]) > w(u,v)
 \mathtt{minEdge}[\mathtt{v.comp}] = (u,v)
 '''for''' k \in Component 
 T\mathtt{.addEdge}(\mathtt{minEdge}[k]) // Добавляем ребро, если его не было в T
 '''return''' T 
|}

==Пример==
{| class = "wikitable"
! Изображение !! Компоненты связности !! Описание
|-align="center"
|[[Файл:Boruvka_1.png|250px]]
| \{A\}\{B\}\{C\}\{D\}\{E\}\{F\}\{G\}
|Начальный граф G. Каждая вершина является компонентой (синие окружности).
|-align="center"
|[[Файл:Boruvka_2.png|250px]]
| \{ABDF\}\{CEG\}
|На первой итерации внешнего цикла для каждой компоненты были добавлены минимальные сопряженные ребра. Некоторые ребра добавлены несколько раз (AD и CE). Осталось две компоненты.
|-align="center"
|[[Файл:Boruvka_3.png|250px]]
| \{ABCDEFG\}
|На последней итерации внешнего цикла было добавлено минимальное ребро, соединяющее две оставшиеся компоненты (ребро BE). Осталась одна компонента. Минимальное остовное дерево графа G построено. 
|-
|}

==Асимптотика==
На i -ой итерации внешнего цикла каждая компонента состоит как минимум из двух компонент из (i - 1) -й итерации. Значит, на каждой итерации число компонент уменьшается как минимум в 2 раза. Тогда внешний цикл повторяется O(\log{V}) раз, так как количество компонент изначально равно количеству вершин. Что же касается внутреннего цикла, то он выполняется за O(E), где E {{---}} количество рёбер в исходном графе. Следовательно конечное время работы алгоритма O(E\log{V}).

==См. также==
* [[Алгоритм Прима]]
* [[Алгоритм Краскала]]
* [[Алгоритм двух китайцев]]

== Источники информации ==
* [http://rain.ifmo.ru/cat/view.php/vis/graph-spanning-trees/mst-2006 Визуализатор алгоритма]
* [http://www.csee.wvu.edu/~ksmani/courses/fa01/random/lecnotes/lecture11.pdf Minimum Spanning Trees]
* [[wikipedia:ru:Алгоритм Борувки|Алгоритм Борувки— Википедия]]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Остовные деревья ]]