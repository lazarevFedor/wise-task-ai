'''Метод проталкивания предпотока''' {{---}} обобщенный алгоритм нахождения максимального [[Определение сети, потока#Определение потока|потока]] в [[Определение сети, потока#Определение сети|сети]]. В отличие от [[Алоритм Эдмондса-Карпа|алгоритма Эдмондса-Карпа]] и [[Схема алгоритма Диница|алгоритма Диница]] не является частным случаем [[Алгоритм Форда-Фалкерсона, реализация с помощью поиска в глубину|метода Форда-Фалкерсона]].

== Определения ==

{{Определение
|definition=
'''Предпотоком''' (англ. ''preflow'') будем называть функцию f: V \times V \rightarrow \mathbb{R} , удовлетворяющую следующим свойствам:
1) f(u, v) = -f(v, u) (антисимметричность)

2) f(u, v) \leqslant c(u, v) (ограничение пропускной способностью)

3) \forall u \in V \setminus \{s, t\} \quad \sum\limits_{v \in V} f(v, u) \geqslant 0 (ослабленное условие сохранения потока)
}}
Как можно заметить, по своим свойствам предпоток очень похож на поток и отличается лишь тем, что для него не выполняется закон сохранения потока.

{{Определение
|definition=
'''Избыточным потоком''' (англ. ''excess flow''), входящим в вершину u , назовем величину e(u) = \sum \limits_{v \in V} f(v, u) .
Тогда вершина u \in V \setminus \{s, t\} будет называться '''переполненной''' (англ. ''overflowing''), если e(u) > 0 .
}}
[[Файл:OrGraphExample.png|left|thumb|Пример сети с истоком A и стоком D. Вершина B является переполненной.]]
{{Определение
|definition=
Функция h: V \rightarrow \mathbb{Z}_+ называется '''высотой вершины''' (англ. ''vertex label''), если она удовлетворяет условиям:
1) h(s) = \left\vert V \right\vert 

2) h(t) = 0 
3) \forall (u, v) \in E_f \quad h(u) \leqslant h(v) + 1
}}

== Описание ==
Пусть дан граф G, в котором выделены две вершины: исток S и сток T, а у каждого ребра определена пропускная способность C(u,v). Поток F можно представить как поток вещества, которое могло бы пройти по сети от истока к стоку, если рассматривать граф как сеть труб с некоторыми пропускными способностями. То есть поток {{---}} функция F(u,v), определённая на множестве рёбер графа.
Задача заключается в нахождении максимального потока.

== Идея ==
Для понимания идеи алгоритма представим, что наша сеть {{---}} система из резервуаров, находящихся на определенной высоте, и соединяющих их труб с заданными пропускными способностями, соответствующих вершинам и рёбрам в исходной сети. Сам алгоритм можно представить как процесс поочередного "переливания" жидкости (операция проталкивания) из одного резервуара в другие, находящиеся на меньшей высоте, до тех пор пока не перестанет существовать резервуар, соответствующий переполненной вершине. Может случиться ситуация, что все трубы, выходящие из переполненной вершины u , ведут к вершинам, находящимся на такой же высоте что и u или выше её. В таком случае поднимем резервуар (операция подъёма), соответствующий данной вершине, таким образом, чтобы его высота стала на единицу больше, чем высота самого низкого из смежных резервуаров. После подъёма будет существовать по крайней мере одна труба, по которой можно пропустить жидкость.

В итоге, у нас не останется ни одной переполненной вершины, та часть потока, которая могла пройти к стоку, окажется там, остальная же вернется в исток. В такой ситуации предпоток превращается в обычный поток, так как для каждой вершины выполняется условие сохранения потока. Как будет показано далее, предпоток становится не только обычным, но и максимальным потоком.

== Операции ==
Как упоминалось ранее, в алгоритме выполняются две основные операции: проталкивание из переполненной вершины избытка потока в смежные вершины, высота которых меньше, чем у переполненной, и подъём вершины.
=== Проталкивание (push) ===
Операция проталкивания из вершины u в вершину v может применяться тогда, когда e(u) > 0 , то есть вершина u является переполненной, c_f(u, v) > 0 и h(u) = h(v) + 1 .

Данная операция работает следующим образом: по ребру (u, v) пропускается максимально возможный поток, то есть минимум из избытка вершины u и остаточной пропускной способности ребра (u, v) , вследствие чего избыток вершины u , остаточная пропускная способность ребра (u, v) и поток по обратному ребру (v, u) уменьшаются на величину потока, а избыток вершины v , поток по ребру (u, v) и остаточная пропускная способность обратного ребра (v, u) увеличиваются на эту же величину.

 '''function''' push('''Node''' u, '''Node''' v)
 d = min(e(u), c(u, v) - f(u, v))
 f(u, v) += d
 f(v, u) = -f(u, v)
 e(u) -= d
 e(v) += d

По своему результату все проталкивания можно разделить на 2 группы. Будем называть проталкивание из вершины u в вершину v '''насыщающим''', если после него остаточная пропускная способность ребра (u, v) стала равна нулю. Все остальные проталкивания будем называть '''ненасыщающими'''. Подобная классификация проталкиваний понадобится нам при оценке их количества.

=== Подъём (relabel) ===
Операция подъёма применима для вершины u , если e(u) > 0 и \forall (u, v) \in E_f \quad h(u) \leqslant h(v) . 

То есть, для переполненной вершины u применима операция подъёма, если все вершины, для которых в остаточной сети есть рёбра из u , расположены не ниже u . Следовательно, операцию проталкивания для вершины u произвести нельзя.

В результате подъёма высота текущей вершины становится на единицу больше высоты самый низкой смежной вершины в остаточной сети, вследствие чего появляется как минимум одно ребро, по которому можно протолкнуть поток.

 '''function''' relabel('''Node''' u)
 h(u) = min{h(v): f(u, v) - c(u, v) f(u, v) = 
\begin{cases}
 c(u, v), & u = s \\
 -c(u, v), & v = s \\
 0, & u \neq s \text{ and } v \neq s
\end{cases}

 h(u) = 
\begin{cases}
 \left\vert V \right\vert, & u = s \\
 0, & u \neq s
\end{cases}

 '''function''' initializePreflow('''Node''' s)
 '''for''' u \in V
 h(u) = 0
 e(u) = 0
 '''for''' (u, v) \in E
 f(u, v) = 0
 f(v, u) = 0
 '''for''' u: (s, u) \in E
 f(s, u) = c(s, u)
 f(u, s) = -c(s, u)
 e(u) = c(s, u)
 e(s) -= c(s, u)
 h(s) = |V|

После инициализации будем выполнять операции проталкивания и подъёма в произвольном порядке. Утверждается, что количество данных операций конечно, и после завершения работы алгоритма наш предпоток является максимальным потоком.

 '''function''' pushRelabelMaxFlow('''Node''' s, '''Node''' t)
 initializePreflow(s)
 '''while''' e(u) > 0 '''and''' (h(u) = h(v) + 1 '''or''' \forall (u, v) \in E_f h(u) \leqslant h(v))
 '''if''' e(u) > 0 '''and''' h(u) = h(v) + 1
 push(u, v)
 '''if''' e(u) > 0 '''and''' \forall (u, v) \in E_f h(u) \leqslant h(v) 
 relabel(u)
[[Файл:OrGraphPush0.png|545px|left|Пример сети.]] [[Файл:OrGraphPush1.png|545px|right|Сеть после запуска потока, остаточная сеть, применение операции \mathrm{relabel}.]][[Файл:OrGraphPush2.png|545px|left|Применение операции \mathrm{push}.]]

== Корректность алгоритма ==
Для доказательства корректности алгоритма докажем несколько вспомогательных лемм.

{{Лемма
|about = 1
|id = Лемма1
|statement =
Во время выполнения алгоритма \mathrm{pushRelabelMaxFlow} никакие свойства высоты не нарушаются.
|proof =
Доказательство проведем по числу выполненных операций проталкивания и подъёма.

Для начала покажем, что после выполнения операции \mathrm{initializePreflow} h является функцией высоты. Для всех рёбер, не инцидентных s , высота обоих концов равна нулю, что удовлетворяет условиям. Единственными рёбрами (u, v) , для которых не выполняются условия, налагаемые на функцию высоты, то есть для которых h(u) > h(v) + 1 , являются рёбра, у которых u = s . Но после операции \mathrm{initializePreflow} рёбра являются насыщенными и не принадлежат остаточной сети.

Это будет базой нашей индукции. 

Теперь докажем переход: если перед выполнением операции проталкивания или подъёма h является функцией высоты, то и после выполнения операции она останется функцией высоты. Для этого рассмотрим проталкивание и подъём отдельно.

Покажем, что после окончания операции проталкивания утверждение верно. После выполнения операции \mathrm{push}(u, v) в E_f может появиться ребро (v, u) , если до операции по ребру (u, v) протекал нулевой поток, или же ребро (u, v) может насытиться, и тогда оно перестанет принадлежать остаточной сети. В первом случае h(v) = h(u) - 1 , и, следовательно, h остается функцией высоты. Во втором же случае при удалении ребра (u, v) из остаточной сети происходит лишь удаление соответствующих ограничений на высоты u и v , так что h остается функцией высоты.

Теперь рассмотрим операцию подъёма вершины u . По определению данной операции гарантируется, что после её выполнения для любого ребра (u, v) \in E_f выполняется условие h(u) \leqslant h(v) + 1 , то есть все выходящие рёбра удовлетворяют условиям, накладываемым на функцию высоты. Рассмотрим какое-то входящее ребро (w, u) . Так как до операции h являлась функцией высоты, то справедливо h(w) \leqslant h(u) + 1 . После подъёма высота вершины u увеличивается как минимум на единицу, следовательно, после выполнения данной операции h(w) . Таким образом, h и после выполнения операции \mathrm{relabel}(u) остается функций высоты.
}}

{{Лемма
|about = 2
|id = Лемма2
|statement = 
Пусть f {{---}} предпоток в сети G . Тогда для любой переполненной вершины можно выполнить операцию проталкивания либо операцию подъёма.
|proof = 
Рассмотрим вершину u , для которой e(u) > 0 . Для любого ребра (u, v) \in E_f справедливо h(u) \leqslant h(v) + 1 по свойствам функции высоты. Если к вершине u применима операция проталкивания, то лемма доказана. Иначе, для всех рёбер (u, v) \in E_f выполняется соотношение h(u) . Следовательно, h(u) \leqslant h(v) . Но тогда данная вершина удовлетворяет условиям операции подъёма, следовательно, к вершине u можно применить эту операцию.
}}

{{Лемма
|about = 3
|id = Лемма3
|statement = 
Пусть G {{---}} сеть с истоком s и стоком t . f и h {{---}} предпоток и функция высоты соответственно. Тогда в остаточной сети G_f нет пути из s в t .
|proof = 
Докажем от противного.

Предположим, что в G_f существует путь из s в t . Из [[Теорема о существовании простого пути в случае существования пути#Теорема о существовании простого пути в случае существования пути|теоремы о существовании простого пути]] следует, что в G_f также существует и простой путь из s в t . Тогда пусть p = \left \langle v_0, v_1, \dots, v_k \right \rangle {{---}} простой путь, где v_0 = s и v_k = t . А раз p простой, то k . Поскольку h {{---}} функция высоты, то \forall i \in \{0, 1, \dots, k - 1 \} справедливо h(v_i) \leqslant h(v_{i+1}) + 1 . Следовательно, h(s) \leqslant h(t) + k . А так как по определению функции высоты h(t) = 0 , то h(s) \leqslant k , что противоречит условию, что h(s) = \left\vert V \right\vert .
}}

{{Теорема
|statement = 
Если алгоритм \mathrm{pushRelabelMaxFlow} завершается, то вычисленный им предпоток f является максимальным потоком.
|proof = 
Для доказательства покажем, что перед каждой проверкой условия в цикле while f является предпотоком.

Перед началом цикла, после завершения операции \mathrm{initializePreflow}, f является предпотоком.

Внутри цикла выполняются лишь операции проталкивания и подъёма. Операция подъёма не влияет на величины потока, а лишь изменяет высоту вершины, следовательно от операции подъёма не зависит, будет ли f предпотоком. Операция \mathrm{push}(u, v) применяется, если e(u) > 0 , увеличивая поток через ребро (u, v) на величину, не превышающую избыточный поток вершины u и остаточную пропускную способность ребра (u, v) . Следовательно, если перед выполнением операции проталкивания f являлся предпотоком, то и после выполнения проталкивания f останется предпотоком.

После завершения алгоритма для каждой вершины u \in V \setminus \{s, t\} справедливо, что e(u) = 0 , что следует непосредственно из [[#Лемма1|леммы (1)]], [[#Лемма2|леммы (2)]] и того, что перед выполнением операций проталкивания или подъёма f является предпотоком. Но тогда f удовлетворяет условию сохранения потока, то есть сам является потоком.

Поскольку из [[#Лемма1|леммы (1)]] следует, что h является функцией высоты и после завершения алгоритма, то по [[#Лемма3|лемме (3)]] в остаточной сети G_f нет пути из s в t . Но тогда по [[Теорема Форда-Фалкерсона|теореме Форда-Фалкерсона]] f {{---}} максимальный поток.
}}

== Оценка быстродействия ==
Чтобы показать, что алгоритм завершает свою работу, найдём максимальное количество операций проталкивания и подъёма. Для этого докажем несколько вспомогательных лемм.

{{Лемма
|about = 4
|id = Лемма4
|statement = 
Пусть G {{---}} сеть с истоком s и стоком t , и f {{---}} предпоток в G . Тогда из любой переполненной вершины u существует путь в s в остаточной сети G_f .
|proof = 
Докажем лемму методом от противного.

Пусть для вершины u верно, что e(u) > 0 . Пусть также U = \{v: u \leadsto v в G_f \} и \bar{U} = V \setminus U . Предположим, что s \in \bar{U} .

Покажем, что для любой пары вершин v \in U и w \in \bar{U} верно, что f(w, v) \leqslant 0 . Если f(w, v) > 0 , то f(v, w) . Но тогда из этого утверждения следует, что c_f(v, w) = c(v, w) - f(v, w) > 0 , что не может быть верным, так как в таком случае существует путь u \leadsto v \to w в остаточной сети G_f , что противоречит выбору вершины w . Следовательно, для каждой пары вершин v \in U и w \in \bar{U} верно, что f(w, v) \leqslant 0 . Тогда верно и f(\bar{U}, U) \leqslant 0 . Следовательно e(U) = f(V, U) = f(U, U) + f(\bar{U}, U) = f(\bar{U}, U) \leqslant 0 .

Но по определению избыток потока неотрицателен, из чего следует, что для любой вершины v \in U e(v) = 0 , в том числе e(u) = 0 , что противоречит условию переполненности вершины u . 
}}

{{Лемма
|about = 5
|id = Лемма5
|statement = 
Пусть G {{---}} сеть с истоком s и стоком t . Тогда во время выполнения алгоритма \mathrm{pushRelabelMaxFlow} для любой вершины u в сети G верно, что h(u) \leqslant 2 \cdot \left\vert V \right\vert - 1 
|proof = 
По определению функции высоты h(s) = \left\vert V \right\vert и h(t) = 0 , следовательно для истока и стока утверждение леммы выполнено.

Рассмотрим вершину u отличную от истока и стока. Изначально h(u) = 0 \leqslant 2 \cdot \left\vert V \right\vert - 1 . Покажем, что после любой операции подъёма h(u) \leqslant 2 \cdot \left\vert V \right\vert - 1 . Для того, чтобы мы имели право произвести операцию \mathrm{relabel}(u) , вершина u должна быть переполнена. Тогда по [[#Лемма4|лемме 4]] существует простой путь p из u в s в остаточной сети G_f . Рассмотрим этот путь. Пусть p = \left\langle v_0, v_1, \dots, v_k \right\rangle , где v_0 = u и v_k = s . Так как путь p простой, то k \leqslant \left\vert V \right\vert - 1 . По определению функции высоты имеем, что \forall i \in \{0, 1, \dots, k - 1\} h(v_i) \leqslant h(v_{i+1}) + 1. Но тогда для вершин u и v верно, что h(u) \leqslant h(s) + \left\vert V \right\vert - 1 = 2 \cdot \left\vert V \right\vert - 1 
}}

На основании предыдущей леммы покажем верхнюю границу числа подъёмов.

{{Лемма
|about = 6
|id = Лемма6
|statement = 
Пусть G {{---}} сеть с истоком s и стоком t . Тогда во время выполнения алгоритма \mathrm{pushRelabelMaxFlow} общее число подъёмов не превышает 2 \cdot \left\vert V \right\vert ^2 
|proof = 
Так как высоты истока и стока не изменяются в процессе работы алгоритма, то только \left\vert V \right\vert - 2 вершин могут быть подняты. Пусть u \in V \setminus \{s, t\}. Изначально h(u) = 0 , и по [[#Лемма5|лемме (5)]] известно, что h(u) \leqslant 2 \cdot \left\vert V \right\vert - 1 . А так как при выполнении операции \mathrm{relabel}(u) высота вершины увеличивается как минимум на единицу, то максимальное количество подъёмов вершины u также не превышает 2 \cdot \left\vert V \right\vert - 1 . Тогда суммарно число подъёмов не превышает (\left\vert V \right\vert - 2 ) \cdot (2 \cdot \left\vert V \right\vert - 1) \leqslant 2 \cdot \left\vert V \right\vert ^2 .
}}

{{Лемма
|about = 7
|id = Лемма7
|statement = 
После ненасыщающего проталкивания из u в v вершина u перестает быть переполненной.
|proof =
Поскольку проталкивание ненасыщающее, то величина потока, проталкиваемого через ребро (u, v) должна быть равна e(u) . После выполнения проталкивания избыточный поток вершины должен уменьшится на величину проталкиваемого потока, следовательно, после ненасыщающего проталкивания из u в v величина e(u) = 0 .
}}

Следующие две леммы показывают верхнюю границу количества проталкиваний.
{{Лемма
|about = 8
|id = Лемма8
|statement = 
Количество насыщающих проталкиваний при выполнение алгоритма \mathrm{pushRelabelMaxFlow} не превосходит 2 \cdot \left\vert V \right\vert \cdot \left\vert E \right\vert 
|proof = 
Возьмем произвольную пару вершин u и v и рассмотрим насыщающие проталкивания по рёбрам (u, v) и (v, u) . Предположим, что произошло насыщающее проталкивание по ребру (u, v) . Тогда во время проталкивания h(v) = h(u) - 1 . Для того, чтобы могло произойти еще одно насыщающее проталкивание по ребру (u, v) , мы должны для начала протолкнуть поток из v в u , чтобы ребро (u, v) снова появилось в остаточной сети. Но для этого должно выполняться условие h(v) = h(u) + 1 , то есть высота вершины u должна увеличится как минимум на 2. По [[#Лемма5|лемме (5)]] высота вершины не превышает 2 \cdot\left\vert V \right\vert - 1 , следовательно, количество раз, когда высота вершины может увеличится на 2, меньше \left\vert V \right\vert . Поскольку между двумя насыщающими проталкиваниями высота одной из вершин должна увеличится по меньшей мере на 2, то между вершинами u и v их будет не более 2 \cdot\left\vert V \right\vert . Тогда суммарно по всем рёбрам во время работы алгоритма произойдут не более 2 \cdot \left\vert V \right\vert \cdot \left\vert E \right\vert насыщающих проталкиваний.
}}

{{Лемма
|about = 9
|id = Лемма9
|statement = 
Количество ненасыщающих проталкиваний при выполнение алгоритма \mathrm{pushRelabelMaxFlow} не превосходит 4 \cdot \left\vert V \right\vert ^2 (\left\vert V \right\vert + \left\vert E \right\vert) 
|proof = 
Пусть \Phi = \sum \limits_{u: e(u) > 0} h(u). Так как после завершения алгоритма ни одна из вершин не является переполненной, то и величина \Phi после выполнения алгоритма должна равняться нулю.

Для начала рассмотрим, каким образом может увеличиваться величина \Phi . 
Первое, что может увеличить \Phi , это подъём, поскольку, осуществляя данную операцию, мы не изменяем избыточный поток ни у одной вершины, а лишь увеличиваем высоту одной из них. При каждой операции подъёма \Phi увеличивается менее чем на 2 \cdot \left\vert V \right\vert , так как подъём не может увеличить высоту вершины больше, чем её максимальная высота, которая согласно [[#Лемма5|лемме (5)]] может быть не более 2 \cdot \left\vert V \right\vert - 1 . А поскольку из [[#Лемма6|леммы (6)]] известно, что число подъёмов не превышает 2 \cdot \left\vert V \right\vert ^2 , то суммарно подъёмы всех вершин могут увеличить \Phi не более чем на 4 \cdot \left\vert V \right\vert^3 .

Во-вторых, величина \Phi может увеличится при насыщающем проталкивании из u в v , потому что e(u) > 0 и после насыщающего проталкивания, а вершина v может стать переполненной. Увеличение меньше 2 \cdot \left\vert V \right\vert , так как изменения высот не происходит, а высота вершины v не превосходит 2 \cdot \left\vert V \right\vert - 1 . Но по [[#Лемма8|лемме (8)]] известно, что количество насыщающих проталкиваний за все время выполнения алгоритма не превосходит 2 \cdot \left\vert V \right\vert \cdot \left\vert E \right\vert , следовательно, за счет насыщающих проталкиваний \Phi увеличится не более чем на 4 \cdot \left\vert V \right\vert^2 \cdot \left\vert E \right\vert .

Итого, получаем, что величина \Phi не может быть больше 4 \cdot \left\vert V \right\vert ^2 \cdot (\left\vert V \right\vert + \left\vert E \right\vert) .

Теперь покажем, что ненасыщающее проталкивание уменьшает \Phi как минимум на единицу. Пусть произошло ненасыщающее проталкивание из вершины u в v . Согласно [[#Лемма7|лемме 7]] после ненасыщающего проталкивания вершина u перестает быть переполненной, следовательно, \Phi уменьшается на величину её высоты. После проталкивания вершина v является переполненной, и поэтому \Phi могла увеличится на h(v) . Поскольку h(u) = h(v) - 1 , то при каждом ненасыщающем проталкивании \Phi уменьшается по меньшей мере на единицу.

Зная верхнюю границу величины \Phi , её значение после выполнения алгоритма и то, что при каждом ненасыщающем проталкивании \Phi уменьшается минимум на единицу, то можно сделать вывод, что количество ненасыщающих проталкиваний не больше чем 4 \cdot \left\vert V \right\vert ^2 (\left\vert V \right\vert + \left\vert E \right\vert) .
}}

{{Теорема
|statement =
Пусть G {{---}} сеть. Тогда любая реализация метода \mathrm{pushRelabelMaxFlow} для G завершает свою работу, и число основных операций составляет O(V^2E) 
|proof =
Из [[#Лемма6|леммы 6]], [[#Лемма8|леммы 8]] и [[#Лемма9|леммы 9]] следует, что число операций подъёма и проталкиваний не превышает 2 \cdot \left\vert V \right\vert ^2 + 2 \cdot \left\vert V \right\vert \cdot \left\vert E \right\vert + 4 \cdot \left\vert V \right\vert ^2 (\left\vert V \right\vert + \left\vert E \right\vert) = O(V^2E) . А так как количество операций ограничено, то независимо от реализации алгоритм завершит свою работу.
}}

==См. также==
* [[Определение сети, потока]]
* [[Схема алгоритма Диница|Алгоритм Диница]]
* [[Алгоритм Эдмондса-Карпа]]
* [[Алгоритм Форда-Фалкерсона, реализация с помощью поиска в глубину|Алгоритм Форда-Фалкерсона]]

== Источники ==
* Кормен Т., Лейзерсон Ч., Ривест Р. Алгоритмы: построение и анализ. — 2-е изд. — М.: Издательский дом «Вильямс», 2011. — С. 762—773.
* [http://ru.wikipedia.org/wiki/Алгоритм_проталкивания_предпотока Алгоритм проталкивания предпотока — Википедия]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Задача о максимальном потоке]]