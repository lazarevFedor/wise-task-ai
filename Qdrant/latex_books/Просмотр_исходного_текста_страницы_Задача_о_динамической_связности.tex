{{Задача
|definition = Есть [[Основные_определения:_граф,_ребро,_вершина,_степень,_петля,_путь,_цикл#Неориентированные_графы|неориентированный граф]] из n вершин, изначально не содержащий рёбер. Требуется обработать m запросов трёх типов:
* \mathrm{add(u,v)} {{---}} добавить ребро между вершинами u и v;
* \mathrm{remove(u,v)} {{---}} удалить ребро между вершинами u и v;
* \mathrm{connected(u,v)} {{---}} проверить, лежат ли вершины u и v в одной компоненте связности.
}}
== Динамическая связность в лесах ==
Если задача такова, что в графе нет и не может быть циклов, то она сводится к задаче о связности в [[Деревья Эйлерова обхода|деревьях эйлерова обхода]]. Время работы каждого запроса для упрощённой задачи {{---}} O(\log n), где n {{---}} количество вершин в графе.

== Обобщение задачи для произвольных графов ==

Существуют задачи, в которых граф не обязательно на протяжении нашей работы после каждой операции добавления ребра остаётся лесом. Для решения таких задач в каждой компоненте связности выделим [[Остовные деревья: определения, лемма о безопасном ребре|остовные деревья]], которые образуют остовный лес. 

[[Файл:Graph.jpg|530px|thumb|left|Граф]] [[Файл:Spanforest.jpg|530px|thumb|right|Остовный лес в графе]]

===Проверка связности===
Граф и его остовный лес {{---}} одно и то же с точки зрения связности. Поэтому проверка связности в графе сводится к проверке связности в остовном лесе и решается за O(\log n).O(\log n). Операция проверки сводится к проверке связности в остовном лесе и работает также за O(\log n).-->

===Добавление ребра===
Чтобы разобраться с тем, как изменится граф и остовный лес при добавлении и удалении ребра, введём функцию l(e):E{\rightarrow}[0;\log n] и назовём её ''уровнем ребра'' e. Уровни ребра можно распределить любым способом, но для всех i должно выполняться следующее свойство: размер каждой компоненты связности G_i не превосходит \dfrac{n}{2^i}. Здесь графы G_i определяются так: G_i=\langle V, E\rangle: \{e \in E \mid l(e) \geqslant i\}.

Очевидно, что G_{\log n} \subseteq G_{\log n-1} \subseteq \ldots \subseteq G_1 \subseteq G_0 = G. Выделим в графах остовные леса таким образом, что F_{\log n} \subseteq F_{\log n-1} \subseteq \ldots \subseteq F_1 \subseteq F_0, где F_i {{---}} остовный лес графа G_i.

Удобнее всего новому ребру давать уровень 0. В этом случае изменится только G_0, так как в остальные подграфы G_i рёбра нулевого уровня не входят. После вставки нового ребра нам нужно проверить, были ли вершины u и v в одной компоненте связности до того, как мы вставили ребро. Если они лежали в разных компонентах, то необходимо новое ребро добавить и в остовный лес F_0.

====Псевдокод====
 
 '''function''' \mathrm{add}('''Node''' u, '''Node''' v):
 '''Edge''' e = \langle u, v\rangle
 e.level = 0
 G_0 = G_0 \cup eG_0, e)-->
 '''if not''' \mathrm{connected(u,v)}
 F_0 = F_0 \cup eF_0, e)-->

===Удаление ребра===
{{Утверждение
|statement=Если ребро, которое мы хотим удалить, не принадлежит остовному лесу, то связность между любой парой вершин сохранится.
|proof=Докажем от противного. Допустим, что это не так. Понятно, что при разрезании ребра нового пути между вершинами не появится.
Предположим, что нарушилась связность для каких-то двух вершин. Значит, мы убрали мост. А любой мост принадлежит всем остовным деревьям его компоненты. Противоречие.
}}
[[Файл:Is_there_xy.jpg|200px|thumb|right|Компонента связности T.]]

Таким образом, если мы удалили ребро не из остовного леса, то нам не придётся перестраивать лес и пересчитывать значение \mathrm{connected(u,v)}.

Рассмотрим случаи, когда мы берём ребро из леса. Тогда необходимо выяснить, является ли данное ребро мостом в графе, и выполнить соответствующие действия.

Проверим, является ли ребро мостом. У ребра uv известен уровень, пусть он равен i. Попробуем найти другое ребро (xy), соединяющее поддеревья T_u и T_v, на которые распалось остовное дерево исследуемой компоненты T.

{{Утверждение
|statement=Если ребро xy существует, то его уровень не больше i.
|proof=От противного. Пусть l(xy)=j, где j > i. Тогда вершины x и y каким-то образом связаны в F_j (либо непосредственно ребром xy, либо каким-то другим путём). Но F_j \subseteq F_i. Значит, в F_i между x и y сохранился путь из рёбер уровня не меньше j и появился другой путь через uv. Приходим к противоречию, так как в F_i все компоненты должны быть деревьями.
}}

Чтобы найти xy, выберем из поддеревьев T_u и T_v наименьшее. Не умаляя общности, будем считать, что |T_u|\leqslant|T_v|. Так как всегда из двух слагаемых можно выбрать одно такое, что оно не превосходит половины их суммы, имеем важное свойство: |T_u|\leqslant\dfrac{|T_u|+|T_v|}{2}=\dfrac{|T|}{2}. Также нам известно, что T \subseteq F_i, а значит, |T|\leqslant\dfrac{n}{2^i}. Отсюда |T_u|\leqslant\dfrac{n}{2^{i+1}}. Это неравенство позволит нам увеличивать уровни рёбер при необходимости.

Будем искать ребро xy следующим образом:
# Выбираем любое ребро уровня i, выходящее из вершины, принадлежащей T_u. 
# Если выбранное ребро ведёт в T_v, выходим из цикла и добавляем ребро xy в остовные леса F_i, для которых i\leqslant l(xy) и выходим из цикла;
# Если выбранное ребро ведёт в другую вершину поддерева T_u, увеличиваем его уровень на 1;
# Если есть непроверенные рёбра на интересующем нас уровне i, переходим к пункту 1;
# Если таких рёбер уровня i не осталось и i>0, рассматриваем уровень на единицу меньший и переходим к пункту 1;
# Если все рёбра просканированы и i=0, то uv является мостом.

'''Замечание.''' Увеличив уровень ребра на единицу, нужно не забыть обновить G_{i+1} и F_{i+1}.
====Оценка времени работы====
Пункт 2 работает за O(\log^2 n), так как после выхода из цикла мы добавляем ребро за O(\log n) на каждом уровне, а количество уровней не больше \log n.

Пусть до момента, когда мы нашли нужное ребро, мы сделали S неудачных сканирований. После каждого такого сканирования нам приходится добавлять новые рёбра в G_{i+1}, что стоит O(\log n). Получаем сложность удаления одного ребра O(\log^2{n}+S\cdot\log n). 

Выразим сложность одной операции \mathrm{remove} другим способом. Для n вершин и m вызовов процедуры сложность равна O(\log^2{n}\cdot m+\log n\cdot\displaystyle \sum_{i=1}^m S_i), что не превосходит O(\log^2{n} \cdot m+\log n\cdot\log n\cdot m), так как уровень ребра m раз рос максимум до \log n. Отсюда суммарная сложность всех запросов равна O(\log^2{n}\cdot m), а для одного запроса мы решаем задачу за O(\log^2{n}).

====Псевдокод====

 '''function''' \mathrm{remove}('''Node''' u, '''Node''' v):
 '''Edge''' e = \langle u, v\rangle
 '''for''' i = e.level '''downto''' 0
 G_i = G_i\setminuseG_i, e)--->
 F_i = F_i\setminuseF_i, e)--->
 '''Edge''' e2
 '''for''' e2 = \langle x, y\rangle : e2.level == i '''and''' x \in T_u
 '''if''' y \in T_v 
 '''for''' j = i '''downto''' 0
 F_j = F_j \cup e2F_i, e2)-->
 '''return'''
 '''else''' 
 e2.level++
 G_{i+1} = G_{i+1} \cup e2F_i, e2)-->

== См. также ==
* [[Деревья Эйлерова обхода|Деревья эйлерова обхода]]
* [[Задача о динамической связности оффлайн]]

== Источники информации ==
* [https://en.wikipedia.org/wiki/Dynamic_connectivity Dynamic connectivity {{---}} Википедия]
* [http://numeralis.ru/algoritmyi-i-strukturyi-dannyih-poiska-dinamicheskaya-svyaznost-v-grafah-babenko-maksim/ Лекции {{---}} Академия Яндекса]

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Связность в графах]]