== Определение слоистой сети == 
Для начала определим для каждой вершины v данной сети G длину кратчайшего s \leadsto v пути из истока и обозначим её d[v] (для этого можно воспользоваться [[Обход в ширину|обходом в ширину]]).

В слоистую сеть включаем только те рёбра (u,v) исходной сети, для которых d[u] + 1 = d[v]. 
Полученная сеть ациклична, и любой s \leadsto t путь в слоистой сети является кратчайшим путём в исходной, из свойств обхода в ширину.
[[Файл:Слоистая_сеть.png|500px |thumb|center| Слоистая сеть с пятью слоями. s = 0, t = 6]]

В примере рёбра, обозначенные пунктиром, не входят в слоистую сеть.

Слоистую сеть для графа G будем называть '''вспомогательной сетью'''.

== Алгоритм ==
Пусть дана [[Определение сети, потока | сеть]]. Требуется найти в этой сети [[Определение сети, потока |поток]] f(u,v) из s в t максимальной величины.
=== Схема алгоритма ===
#Для каждого ребра (u,v) данной сети G зададим f(u,v) = 0.
#Построим вспомогательную сеть G_L из [[Дополняющая сеть, дополняющий путь|дополняющей сети]] G_f данного графа G. Если d[t] = \infty, остановиться и вывести f.
#[[Алгоритм поиска блокирующего потока в ациклической сети|Найдём блокирующий поток]] f' в G_L.
#Дополним поток f найденным потоком f' и перейдём к шагу 2.

=== Корректность алгоритма ===
Покажем, что если алгоритм завершается, то на выходе у него получается поток именно максимальной величины.

В самом деле, предположим, что в какой-то момент во вспомогательной сети, построенной для остаточной сети, не удалось найти блокирующий поток. Это означает, что сток вообще не достижим во вспомогательной сети из истока. Но поскольку она содержит в себе все кратчайшие пути из истока в остаточной сети, это в свою очередь означает, что в остаточной сети нет пути из истока в сток. Следовательно, применяя [[Теорема Форда-Фалкерсона|теорему Форда-Фалкерсона]], получаем, что текущий поток в самом деле максимален.

=== Асимптотика алгоритма ===
{{Теорема
|statement=
Расстояние между истоком и стоком строго увеличивается после каждой фазы алгоритма, т.е. d'[t] > d[t], где d'[t] — значение, полученное на следующей фазе алгоритма.
|proof=
Проведём доказательство от противного. Пусть длина кратчайшего пути из истока в сток останется неизменной после очередной фазы алгоритма. Вспомогательная сеть строится по остаточной. Из предположения следует, что в остаточной сети будут содержаться только рёбра остаточной сети перед выполнением данной фазы, либо обратные к ним. Из этого получаем, что нашёлся s \leadsto t путь, который не содержит насыщенных рёбер и имеет ту же длину, что и кратчайший путь. Но этот путь должен был быть «заблокирован» блокирующим потоком, чего не произошло. Получили противоречие. Значит длина изменилась.
}}
Поскольку длина кратчайшего s \leadsto t пути не может превосходить n - 1, то, следовательно, алгоритм Диница совершает не более n - 1 фазы.
Таким образом, в зависимости от того, каким алгоритмом нахождения блокирующего потока мы пользовались, весь алгоритм Диница может выполняться за O(VE^2) или за O(V^2E). Также возможно достичь асимптотики O(VE\log V), если использовать [[Link-Cut_Tree | динамические деревья Слетора и Тарьяна]].

==Реализация==
В данной реализации не строится вспомогательная сеть G_L, а вычисляются значения d[u] {{---}} кратчайших путей s \leadsto u.

c[u][v] {{---}} пропускная способность ребра (uv).

f[u][v] {{---}} поток через ребро (uv).

p[u] {{---}} [[Алгоритм_поиска_блокирующего_потока_в_ациклической_сети#.D0.A3.D0.B4.D0.B0.D0.BB.D1.8F.D1.8E.D1.89.D0.B8.D0.B9_.D0.BE.D0.B1.D1.85.D0.BE.D0.B4 | номер первого неудалённого ребра, идущего из u]]

 '''bool''' bfs():
 заполняем массив d значениями, равными \infty
 d[s] = 0
 Q.push(s)
 '''while''' !Q.isEmpty
 u = Q.pop()
 '''for''' (uv) \in E(G)
 '''if''' f[u][v] \infty
 d[v] = d[u] + 1
 Q.push(v)
 '''return''' d[t] != \infty

 // поиск блокирующего потока
 // u {{---}} номер вершины
 // minC {{---}} минимальная пропускная способность дополняющей сети на пройденном dfs пути
 '''int''' dfs(u, minC):
 '''if''' u == t '''or''' minC == 0
 '''return''' minC
 '''for''' v = p[u] '''to''' |V(G)| - 1
 '''if''' d[v] == d[u] + 1 // это условие эквивалентно поиску во вспомогательной слоистой сети
 delta = dfs(v, min(minC, c[u][v] - f[u][v]))
 '''if''' delta != 0
 f[u][v] += delta // насыщаем рёбра по пути dfs
 f[v][u] -= delta
 '''return''' delta
 p[u]++
 '''return''' 0

 '''int''' findMaxFlow():
 maxFlow = 0
 '''while''' bfs() // пересчитываем d[i], заодно проверяем достижима ли t из s
 заполняем p нулями
 flow = dfs(s, \infty)
 '''while''' flow != 0
 maxFlow += flow
 flow = dfs(s, \infty)
 '''return''' maxFlow

== Источники ==
*[http://ru.wikipedia.org/wiki/Алгоритм_Диница Википедия {{---}} Алгоритм Диница]
*[http://www.e-maxx.ru/algo/dinic MAXimal::algo::Алгоритм Диница]
*Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн Алгоритмы: построение и анализ — 2-е изд. — М.: «Вильямс», 2007. — С. 1296. — ISBN 5-8489-0857-4

[[Категория: Алгоритмы и структуры данных]]
[[Категория: Задача о максимальном потоке ]]