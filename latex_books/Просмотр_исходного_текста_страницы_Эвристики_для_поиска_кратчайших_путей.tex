== Проблема поиска кратчайшего пути ==
{{Задача
|definition = 
Дана сеть автомобильных дорог:
* ориентированный граф G=(V,E), где
** V — множество перекрёстков,
** E — множество дорог;
* l(u,v) \geqslant 0 — среднее время, которое занимает проезд по дороге,
* |V|=n, |E|=m,
* отправная точка — вершина s, пункт назначения — вершина t
Цель: найти кратчайший путь s \rightsquigarrow t
}}
Количество перекрёстков и дорог может быть очень большим, тогда обычные алгоритмы поиска пути будут работать очень долго, поэтому попытаемся оптимизировать их для более быстрой работы.

==Алгоритм Дейкстры==
[[Алгоритм Дейкстры]]:
* На каждом шаге выбирает из множества непросмотренных вершин вершину с наименьшим расстоянием до старта и релаксирует рёбра, исходящие из неё,
* завершает свою работу, когда цель достигнута (или просмотрены все вершины).

Скорость работы алгоритма Дейкстры сильно зависит от скорости операций с приоритетной очередью.

Поскольку мы рассматриваем сеть автомобильных дорог, то m = O(n) (граф планарен почти везде).

Для фибоначчиевых куч время работы алгоритма составляет O(n\log{n}+n), для двоичных куч: O(n\log{n})

Но на практике чаще используются 2-, 4- и 8-ичные кучи: они более простые, оценка времени работы содержит меньшее количество скрытых констант.

===Улучшения алгоритма Дейкстры===
====Многоуровневые корзины (англ. ''multi-level buckets, MLB'')====
[[Файл:multilevel_buckets.jpg ]]

{| class="wikitable" style="width:7cm; text-align: center" border=1 align="right"
 |+ Сравнение различных структур данных для поиска кратчайшего пути на карте Европы (CPU 2,4GHz, 16MB RAM)
 ! Структура данных !! Время работы (сек)
 |- 
 | Двоичная куча || 12,38
 |-
 | 4-куча || 11,53
 |-
 | 8-куча || 11,52
 |-
 | MLB || 9,36
 |-
 | MLB + калибровка || 8,04
 |-
 |}
Подходит только графов с целочисленными рёбрами.
* Будем складывать вершины в "корзины" B[i] = \{u \in B[i] : d(u)=i\},
* наша структура данных будет поддерживать индекс L = \{\forall i : i
* на каждом шаге алгоритма, если B[L] пусто, то увеличим L, а иначе достанем одну вершину из B[L],
* при релаксации будем убирать вершину из исходной корзины и класть в корзину, соответствующую новому значению d(u).

Можно заметить, что при такой реализации, все операции с приоритетной очередью будут выполняться за O(1). Тогда, для одноуровневой реализации время работы алгоритма Дейкстры можно оценить как O(m+nC), где C — максимальная длина ребра в графе.

При двухуровневой реализации будем поддерживать два уровня корзин: первый уровень будет соответствовать одноуровневой реализации, а корзины второго уровня будут содержать диапазон значений корзин первого уровня, которые в них входят. В этом случае, нам нужно поддерживать два индекса L_{top} и L_{bottom} для каждого из уровней соответственно.

При такой реализации, время работы алгоритма Дейкстры можно оценить как O(m+n(1+ \sqrt{C}))

====Калибровка (англ. ''caliber'')====
Введём величину ''калибр'' вершины c(v) — вес минимального ребра, входящего в v , или \infty, если в вершину не входит ни одно ребро. Будем говорить, что текущее значение d(v) точно, если оно равно длине пути s \rightsquigarrow v. 
{{Лемма
|about = 1
|statement = 
Предположим, что длины рёбер неотрицательны. Пусть \mu — минимальное из текущих значений d(v):v \in V. Тогда, если существует такая вершина u, что \mu + c(u) \geqslant d(u), то текущее значение d(u) точно.
}}
Эта лемма позволяет нам смягчить правило выбора текущей вершины в алгоритме Дейкстры, при этом сохраняя инвариант (почти все вершины обрабатываются единожды).
Калибровка использует Лемму 1 чтобы находить и обрабатывать вершины с точными текущими значениями расстояния до них.

Модифицируем нашу MLB — структуру: будем хранить помеченные вершины в двух структурах: дерево поиска F и приоритетная очередь B, реализованная на MLB.
Алгоритм, приведённый ниже, называется ''алгоритмом умной очереди'' (англ. ''smart queue''). 

Вершины в F будут иметь точные метки d(u). Если F непусто, мы удалим оттуда вершину и прорелаксируем всех её соседей. Если же F пусто, мы достанем из
B вершину с минимальной меткой и прорелаксируем всех её соседей.

Рассмотрим механизм релаксации: пусть мы уменьшаем d(u). Заметим, что в этом случае u не могло лежать в F (иначе d(u) было не точно). Если u \in B — применим \mathtt{decrease — key} к u. Эта операция либо переместила u внутри B, либо определила, что метка d(u) точна и переместила u в F.
Если же u \notin F и u \notin B, мы применим операцию \mathtt{insert}, и u запишется в
F или B, в зависимости от того, выполняется ли условие леммы.

====Двунаправленный поиск====
Мы можем уменьшить количество посещённых вершин в алгоритме Дейкстры, просто запустив его и из начальной и из конечной вершины. Такая эвристика не испортит скорость работы в худшем случае.

Создадим две приоритетных очереди и запустим на одной из них алгоритм Дейкстры, ищущий d_{forward}(v) из s, а на другой — ищущий d_{reverse}(v) из t. Алгоритм завершит свою работу, когда какая-нибудь вершина z будет удалена из обеих очередей. 

Тонкость этого алгоритма заключается в том, что кратчайший путь s \rightsquigarrow t не обязательно пройдёт через вершину z. Поэтому после остановки двунаправленного поиска, нам необходимо перебрать все рёбра из вершин, имеющих d_{forward}(u) в 
вершины с d_{reverse}(v) и найти ребро uv с минимальным d_{forward}(u)+\ell(uv)+ d_{reverse}(v) . Если эта величина меньше, чем длина первоначально найденного пути — то это и есть результат работы алгоритма.

На практике, такой двунаправленный поиск быстрее обычного алгоритма Дейкстры примерно в два раза.

==Алгоритм A*==
Приведём немного изменённую версию [[Алгоритм A*|этого алгоритма]].

Возьмём функцию h(v): V \rightarrow \mathbb{R} — ''потенциал'' (aнгл. ''potential'') вершины. Тогда, с её помощью можно определить ''потенциальную стоимость'' (англ. ''reduced cost'') каждого ребра как \ell_{h}(v,w) = \ell(v,w)-h(v)+h(w)

Заметим, что замена \ell на \ell_{h} не изменит кратчайших путей: возьмём любой путь P = (s=v_{0},v_{1},...,v_{k},v_{k+1}=t). Тогда \ell_{h}(P) = \ell_{h}(s,v_{1}), \ell_{h}(s,v_{w}). Тогда \ell_{h}(P) = \ell_{h}(s,v_{1})+\ell_{h}(v_{1},v_{2})+...+\ell_{h}(v_{k},t) = \ell(s,v_{1})-h(s)+h(v_{1})+\ell(v_{1},v_{2})-h(v_1)+h(v_{2})+...+\ell(v_{k},t)-h(v_k)+h(t) = \ell(P)-h(s)+h(t). 

Таким образом длины все путей s \rightsquigarrow t изменятся на одну и ту же величину h(t)-h(s) 

В нашем случае, алгоритм A* будет эквивалентен алгоритму Дейкстры, на графе G_{h}, у которого стоимости рёбер заменили на их потенциальные стоимости. На каждом шаге необходимо будет выбирать из очереди вершину v с минимальным значением \ell(P_{s \rightsquigarrow v})-h(s)+h(v). Очевидно, h(s) будет одинаковым для любой вершины v.

Назовём функцию h правдоподобной (англ. ''feasible''), если \forall (u,v): \ell_{h}(u,v) \geqslant 0. Известно, что, если h(t)\leqslant 0 и h правдоподобна, то для любого v, h(v) — нижняя граница d(v,t) 

Главное отличие от алгоритма Дейкстры в том, что A* является информированным алгоритмом — он обрабатывает в первую очередь те вершины, которые находятся ближе к результату. 

Скорость работы алгоритма A*:
* в худшем случае — h(v)=0 — вырождается в алгоритм Дейкстры
* в лучшем случае — \forall v: h(v)=d(v,t) 
**\ell_{h}(v,w)=0, если ребро (v,w) лежит на кратчайшем пути, иначе потенциальная стоимость положительна
**все посещённые вершины будут лежать на кратчайшем пути
===Двунаправленный A*===

Для двунаправленной версии алгоритма нам нужны две потенциальные функции:
* p_{f}(v), оценивающая d(v,t)
* p_{r}(v), оценивающая d(s,v)

В этом случае появляется дополнительная проблема: различные потенциальные стоимости у рёбер для различных обходов:
*\ell_{p_{f}}(v,w) = \ell(v,w)-p_{f}(v)+p_{f}(w) — если ребро обрабатывается в обходе, начатом в s
*\ell_{p_{r}}(v,w) = \ell(v,w)-p_{r}(w)+p_{r}(v) — если ребро обрабатывается в обходе, начатом в t

Чтобы избежать этой проблемы, необходимо, чтобы \ell_{p_{f}}(v,w) = \ell_{p_{r}}(v,w) \Leftrightarrow p_{f}(v) + p_{r}(v) = p_{f}(w) + p_{r}(w) = const. Кроме того, функции должны быть монотонными.

Решение — использовать усреднённые потенциальные функции:
*h_{f}(v) = \dfrac{p_{f}(v)-p_{r}(v)}{2}
*h_{r}(v) = \dfrac{p_{r}(v)-p_{f}(v)}{2} = -h_{f}(v)

При таком выборе потенциальных функций, выполняется \forall u : h_{f}(u)+h_{r}(u)=0 и тогда двунаправленный A* становится аналогичен двунаправленному алгоритму Дейкстры

==Двухэтапные алгоритмы==

К сожалению, двунаправленный алгоритм Дейкстры всего в два раза быстрее обычного, а это слишком медленно. Рассмотрим алгоритм поиска кратчайшего пути, состоящий из двух этапов: 
# Препроцессинг:
#* запускается единожды для графа,
#* может занимать много времени,
#* рассчитывает некую вспомогательную информацию.
# Запрос:
#* может использовать данные, полученные во время препроцессинга,
#* запускается по требованию для пары (s,t),
#* должен выполняться очень быстро (в реальном времени).

Можно рассмотреть в этом ключе два примера: 
* Алгоритм Дейкстры: препроцессинг — ничего не делать, запрос — выполнение алгоритма Дейкстры;
* Полный перебор: препроцессинг — посчитать таблицу расстояний размером n \times n (займёт порядка 5 лет времени и 1 петабайта памяти для карты Европы), запрос — обратиться к элементу таблицы.

Оба эти примера — крайние случаи. Нам нужно нечто более гибкое: препроцессинг за часы/минуты, рост количества предпосчитанных данных линейно от размера графа и запросы в реальном времени.

===ALT===

Аббревиатура ALT расшифровывается как A* +Landmarks + Triangle inequality : A* + ориентиры + неравенство треугольника.

#Препроцессинг:
#* взять небольшое количество вершин (например, 16), обозначив их как ориентиры (англ. ''landmarks''),
#* для каждого из ориентиров посчитать кратчайшие пути до всех вершин,
#* сохранить эти пути.
#Запрос:
#* используем A*,
#* если некоторое ребро находится на кратчайшем пути между исходной точкой и ориентиром — по нему идём в первую очередь.

[[Файл:ALT.jpg|right|frame|рис. 1]]
Будем использовать неравенство треугольника для нижних оценок пути (см. рис. 1). Пусть A — один из ориентиров, тогда:
*dist(v,w)\geqslant dist(A,w)-dist(A,v),
*dist(v,w)\geqslant dist(v,A)-dist(w,A),
*dist(v,w)\geqslant \max\{dist(A,w)-dist(A,v),dist(v,A)-dist(w,A)\}.

Эта эвристика хорошо работает, на дорожных графах, для которых верно следующее: как правило, кратчайший путь затрагивает небольшое количество локальных дорог, потом крупную автомагистраль и снова некоторое количество локальных дорог.

Сложности в выборе ориентиров:
* хороший ориентир для запроса s \rightsquigarrow t должен находиться "до" s (точно не будет общих рёбер на кратчайшем пути) или "за" t (чем острее угол, тем меньше отклонение от предварительно посчитанного кратчайшего пути до искомого),
* нам нужно выбрать такие ориентиры, которые будут неплохими для всех запросов.

Выглядит логичным выбирать ориентиры на краю дорожной сети, тогда будет больше острых углов и ориентиры будут лучше.

Существуют различные алгоритмы выбора ориентиров:
====Случайный выбор (random)====
[[Файл:planarLandmarks.jpg|right]]
Как следует из названия, ориентиры выбираются случайным образом

====Плоскостной (planar)====
* Разделим карту на k секторов одинаковой площади,
* возьмём ориентиром наиболее удалённую точку от центра в каждом секторе.

Такой способ подходит, только если граф имеет относительно правильную форму. На практике обычно используется оптимизированная версия этого алгоритма.

====Избирательный (avoid)====
Этот алгоритм добавляет ориентиры по одному, глядя на вершины, которые плохо покрыты текущим набором ориентиров S.

Построим из случайно выбранной вершины r дерево кратчайших путей T_{r}. Весом каждой вершины v в этом дереве назовём разность между истинной длиной пути d(v,r) и нижней оценкой этой длины \underline{d}(v,r), полученной по текущему набору ориентиров. Размером вершины v назовём сумму её веса и размеров всех её потомков в T_{r}. Если поддерево T_{r} с корнем в v содержит ориентир, размер v равен 0.

Начиная с максимальной по размеру вершины, пойдём вниз по дереву T_{r} и найдём лист с максимальным размером. Примем его за новый ориентир.

====Поиск максимального покрытия (maxCover)====
Основным минусом избирательного метода является то, что первый ориентир выбирается случайным образом и выбор последующих ориентиров будет сильно зависеть от первоначального. 

Мы можем улучшить найденные ориентиры, если сначала, используя избирательный метод, найдём набор ориентиров в несколько (обычно, 4) раза больше, чем необходимо, а потом отсеем лишние минимизируя время запроса.

Оценим качество набора ориентиров S основываясь на покрытии дуг. Будем говорить, что ориентир L покрывает дугу (v,w), если вершина v находится на кратчайшем пути L \rightsquigarrow w. То есть, \ell(v,w) = dist(L,w)-dist(L,v), тогда такой выбор ориентира даст нам нижнюю границу для всех путей, содержащих (v,w).

Если хотя бы один ориентир из S покрывает дугу (v,w), то и весь S покрывает эту дугу. 

Этот метод является наилучшим, но является наиболее медленным. Задача выбора ориентиров в этом случае становится NP-полной.

===Reach===
Эта эвристика основывается на интуитивном наблюдении: не стоит посещать "локальные" дороги, когда мы находимся достаточно далеко и от s, и от t

Пусть вершина v лежит на кратчайшем пути P: s \rightsquigarrow t. Тогда, назовём охватом (англ. ''reach'') вершины v относительно P величину r(v,P) = \min\{dist(s,v), dist(v,t)\}. Охватом вершины относительно всего графа назовём величину r(v) = \max\limits_{P} r(v,P) — максимум по всем кратчайшим путям, содержащим v.

Помимо этого, будет полезным ввести понятие охвата ребра. Назовём охватом ребра (v,w)\in P относительно P величину \min\{dist(s,v), dist(w,t)\}. Аналогично, охватом ребра относительно всего графа назовём величину r(v,w) = \max\limits_{P} r((v,w),P) — максимум по всем кратчайшим путям, содержащим (v,w).

[[Файл:reach1.jpg|right]]
Заметим, что вершины с большим охватом находятся вблизи середины некоторого длинного кратчайшего пути, то есть
* на больших автомагистралях вершины имеют большой охват,
* на локальных перекрёстках (внутри населённых пунктов) вершины имеют маленький охват.

Во время обработки ребра (v,w):
* удалим вершину w, если r(w),
* оценка LB(w,t) должна быть подобрана таким образом, чтобы, если бы P=(s,..,v,w,...,t) было кратчайшим путём, r(w) было бы больше. 
[[Файл:reach2.jpg|right]]
Как искать нижнюю оценку длины пути LB(w,t)? 
* Явно: Евклидово расстояние, с помощью ориентиров.
* Неявно: сделать поиск двунаправленным.

Например, радиус R_{t} поиска в обратную сторону может быть нижней оценкой, т.к. если вершина w не была посещена поиском в обратную сторону, то d(w,t)\geq R_{t}

Таким образом, будем удалять w, если r(w)\textless \min\{d(s,v)+\ell(v,w), R_{t}\}

Для улучшения результата, нам необходимо сбалансировать прямой и обратный поиск.

Рассмотрим препроцессинг:

[[Файл:reach3.jpg|right]]
* на начальном этапе \forall v: r(v)\leftarrow 0,
* для каждой вершины s \in V рассмотрим дерево кратчайших путей до всех других вершин T_{s}, 
**найдём наиболее длинный путь P_{s\rightsquigarrow t}, содержащий v, 
**Назовём глубиной вершины d_{s}(v) расстояние от s, высотой вершины h_{s}(v) — расстояние до наиболее далёкого потомка вершины,
** Тогда, охватом вершины в этом дереве будет величина r_{s}(v) = \min\{d_{s}(v),h_{s}(v)\},
** Тогда обновим значение охвата r(v) \leftarrow \max\{r(v),r_{s}(v)\}.

Сложность алгоритма: O(nm), поэтому он слишком медленный для больших графов и его нужно улучшить. 

Финальная версия препроцессинга будет иметь две фазы:
*основная фаза (строятся частично обработанные деревья и добавляются сокращающие путь рёбра)
*фаза отладки (вершины с большим охватом обрабатываются указанным выше алгоритмом — их гораздо меньше, поэтому обработка будет быстрой)

====Сокращение области поиска====
Заметим, что нам нужны только вершины с маленьким охватом r(v)\textless \varepsilon, \varepsilon=const. Заметим также, что если r(v) \geqslant \varepsilon, то существует такой путь P, что на нем лежит вершина v \in P, для которой выполняется условие r(v,P)\geqslant \varepsilon

Назовём кратчайший путь P_{s\rightsquigarrow t} = (s, s',...,v,...,t',t) \varepsilon-минимальным, если выполняются условия:

*dist(s,v)\geqslant\varepsilon,
*dist(s',v)\textless\varepsilon,
*dist(v,t)\geqslant\varepsilon,
*dist(v,t')\textless\varepsilon.

Таким образом, алгоритм будет выглядеть так:
* найдём оценку охвата r'(v), используя только \varepsilon — минимальные пути,
* если r'(v), то оценка корректна: r(v)=r'(v),
* если же r'(v)\geqslant \varepsilon, то она нас не интересует: r(v)\geqslant r'(v).

Полезно будет рассматривать частично обработанные деревья (англ. ''partial trees'') — деревья кратчайших путей, хранящие пути длиной, меньшей определённого порога. Тогда дерево кратчайших путей будет глубиной порядка 2\varepsilon:
* установим G'\leftarrow G и \varepsilon\leftarrow \varepsilon_{0} (маленькое число),
* пока G' не пусто:
** найдём частично обработанное дерево кратчайших путей из v, чтобы найти вершины с охватом r(v) \geqslant \varepsilon,
** удалим из G' оставшиеся вершины (с охватом r(v) \textless\varepsilon, уже обработанные),
** установим \varepsilon\leftarrow 3\varepsilon.
[[Файл:reach5.jpg|right]]
[[Файл:reach6.jpg|right]]

====Пенальти====
Предыдущее улучшение создаёт проблему: мы должны предполагать, что кратчайший путь может начинаться в вершине с маленьким охватом, которые мы отбрасываем на каждой итерации. Для того, чтобы принять их во внимание, мы введём новую величину — пенальти(англ. ''penalty'') — верхнюю оценку на длину кратчайшего пути в "отброшенной" зоне.

Пусть G_{i} = (V_{i},A_{i}) — подграф исходного графа, полученный на i-й итерации алгоритма, описанного выше. Назовём входящим пенальти (in-penalty) вершины v\in V_{i} величину \max\{ \overline{r}(u,v) : u,v \in A \backslash A_{i}\}, если у v было как минимум одно выброшенное в процессе алгоритма входящее ребро, или ноль в противном случае.
Аналогично определим исходящее пенальти для исходящих из вершины рёбер. 

Изменим алгоритм, чтобы заменить вершины на их пенальти. Для этого переопределим глубину и высоту вершины.
* Глубиной вершины v\in T_{x}, где T_{x} — частично обработанное дерево с корнем в x величину depth(v)=d(v)+in\textrm{-}penalty(x) , где d(v) — длина пути от корня до вершины в дереве.
* Чтобы определить высоту вершины, нам нужно понятие "ложных листьев". Для каждой вершины v в дереве кратчайших путей добавим потомка v' — ложный лист, и ребро (v,v') = out\textrm{-}penalty(v). В некотором смысле, v' будет выступать в роли всех рёбер, изначально инцидентных вершине v, которые мы отсекли. Тогда высотой вершины v будет расстояние от неё, до наиболее далёкого ложного листа. Подчеркнём, что в данный момент ложные листья добавляются неявно, и только после того, как дерево будет частично обработано.

====Сокращение путей====
Представим последовательность вершин степени 2 с большим охватом, идущих подряд. Добавим, сокращающее ребро (англ. ''shortcut'') — ребро, проходящее из начала пути в его конец с длиной, равной длине этого пути. Таким образом мы можем уменьшить охваты вершин на этом пути и ускорить препроцессинг (уменьшив количество проходимых рёбер), но увеличим память, необходимую для хранения нашего графа.

На этом шаге мы будем искать пропускаемые (англ. ''bypassable'') вершины. Назовём вершину v пропускаемой, если выполняется одно из двух условий:
* v имеет только одно входящее ребро (u,v) и одно исходящее ребро (v,w),
* v имеет два входящих ребра (u,v), (w,v) и два исходящих ребра (v,w) ,(v,u).
В обоих случаях подразумевается, что u\neq w, то есть у v обязательно есть только два соседа. В первом случае, v — кандидат на односторонний пропуск (англ. ''one-way bypass''), во втором — на двухсторонний (англ. ''two-way bypass''). Мы будем использовать сокращающие рёбра, чтобы пропускать такие вершины.

Линия (line) — путь в графе, содержащий как минимум три вершины, так, что все вершины, кроме начальной и конечной, пропускаемые. Каждая пропускаемая вершина может принадлежать только одной линии. Линии также могут быть односторонне- и двухсторонне- пропускаемыми, в зависимости от типа вершин, которые они содержат. Легко заметить, что на линии могут лежать вершины только одного типа.

Как только мы нашли линию, самым простым решением будет добавить одно сокращающее ребро из начала в конец. Но практика показывает, что лучше сократить ещё и входящие в её состав линии меньшего размера, это ещё более уменьшит охваты пропускаемых вершин. Для этого перед добавлением сокращающего ребра по линии, рекурсивно найдём вершину, которая находится примерно на её середине и обработаем левый и правый отрезки как полноценные линии.
====Удаление пропущенных вершин====
Представим одностороннюю линию, состоящую из трёх вершин u, v, w. Когда мы добавили сокращающее ребро (u,w), мы знали, что ребро (u,v) больше никогда не будет использоваться на кратчайшем пути содержащем подпуть u\rightsquigarrow w. Кроме того, любой кратчайший путь, содержащий (u,v), будет оканчиваться либо в v, либо в близлежащей вершине с низким охватом.
Тогда, корректной верхней оценкой охвата (u,v) является \overline{r}(u,v)=\ell(u,v)+out\textrm{-}penalty(v). Аналогично, \overline{r}(v,w)=\ell(v,w)+in\textrm{-}penalty(v). Зная это, мы можем удалить вершину v и смежные ей рёбра из графа и обновить соответствующие значения пенальти для её соседей.

Такую же процедуру можно проделать с двусторонней линией, т.к. помимо оценок, указанных выше, можно добавить:
* \overline{r}(w,v)=\ell(w,v)+out\textrm{-}penalty(v),
* \overline{r}(v,u)=\ell(v,u)+in\textrm{-}penalty(v).

====Фаза отладки====
Тот факт, что мы используем пенальти, для ускорения вычисления корректных верхних оценок охвата, приводит к тому, что оценки становятся менее точными в процессе работы алгоритма и с ростом пенальти. Следовательно, для вершин, которые дольше находятся в графе, ошибки накапливаются. Это плохо, потом что такие вершины и являются самыми важными в графе — у них высокий охват, их посещает большое количество кратчайших путей. Если бы мы могли сделать их более точными, во время запроса можно было бы пропустить большее количество вершин.

В этом и заключается цель фазы отладки. После того, как мы найдём верные значения верхних оценок, используя частично обработанные деревья, во время фазы отладки мы пересчитаем охват \delta = const вершин с наибольшими значениями охвата (в них больше всего ошибок).

Пусть V_{\delta} \subset G — множество вершин с высоким охватом мощностью \delta. Чтобы пересчитать их охваты, сначала необходимо найти подграф G_{\delta} = (V_{\delta},A_{\delta}). Этот граф содержит не только первоначальные рёбра, но и добавленные во время основной фазы сокращающие рёбра. Затем мы запустим поиск точных значений охвата для каждой вершины этого подграфа. Так как деревья кратчайших путей будут содержать только вершины из G_{\delta}, то нам всё ещё нужно использовать входящие и исходящие пенальти для остальных вершин. Но, тем не менее, они будут меньше, т.к. для самых больших мы подсчитали точное значение охвата.

Во время фазы отладки мы заботимся о точности, а не о скорости, поэтому не добавляем новых сокращающих рёбер и используем точный алгоритм. 
Поэтому, время работы алгоритма как минимум \Omega(\delta^{2})

==Итог==
{| class="wikitable" style="width:17cm; text-align: center" border=1
 |+ Сравнение различных эвристик для поиска кратчайшего пути на карте США
 ! Метод !! Время препроцессинга, м !! Память для препроцессинга, MB !! Сканируемые запросом вершины, шт !! Время запроса, мс
 |- 
 | Алгоритм Дейкстры || - || 536 || 11 808 864 || 5440,5
 |-
 | ALT(16 ориентиров) || 18 || 2563 || 187 968 || 295,45
 |-
 | Reach || 28 || 893 || 2 405 || 1,77
 |-
 |}

{| border="0" cellspacing="0" cellpadding="5"
 |+ Работа различных алгоритмов на карте севера США
 ! Алгоритм Дейкстры !!ALT (16 ориентиров) !! Reach
 |- 
 | [[Файл:Ex1.jpg]] || [[Файл:Ex2.jpg]] || [[Файл:Ex3.jpg]]
 |-
 |}
Условные обозначения:
* зелёный квадрат — начало пути
* синий квадрат — конец пути
* зелёные линии — пути, пройденные прямым обходом
* синие линии — пути, пройденные обратным обходом
* красные ромбы — ориентиры
* жёлтые ромбы — выбранные при поиске пути ориентиры

==См. также==
*[[Алгоритм Дейкстры]]
*[[Алгоритм A*]]

==Источники информации==
*[http://logic.pdmi.ras.ru/midas/sites/default/files/midas-werneck.pdf Презентация Renato Werneck c MIDAS 2010 - основа конспекта]
*[http://research.microsoft.com/pubs/64511/tr-2004-24.pdf A* meets graph theory]
*[http://algo2.iti.kit.edu/schultes/hwy/hhStarSubmit.pdf Highway Hierarhies Star*]
*[http://www.ecc.uic.edu/pub/Bits/TransitGenieDocs/tm_thesis.pdf Heuristic Route Search in Public Transportation Networks]
*[http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/GW05.pdf Computing Point-to-Point Shortest Paths from External Memory]
*[http://research.microsoft.com/pubs/60764/tr-2005-132.pdf Reach for A*]
[[Категория: Алгоритмы и структуры данных]]
[[Категория: Кратчайшие пути в графах ]]